<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JSTACK 分析线程]]></title>
    <url>%2F2019%2F02%2F11%2FJava%2Fjstack-cpu%2F</url>
    <content type="text"><![CDATA[查找 tomcat 线程可以通过两种方式找： jps 一般Bootstrap都是tomcat的 ps -ef |grep tomcat jstack dump 出线程1jstack 23524 &gt; jstack.txt 查看 tomcat 内部线程1top -H -p 23524 （shift+p 按 cpu 排序，shift+m 按内存排序） 将PID换算成16进制，然后在jstack.txt查找nid=0x换算后的数1cat jstack.txt | grep 'nid=0x5be9' -B 5 -A 40 可以看出是JNI的问题，一般就是tomcat jni没配置连接池参数导致的了 加上连接池参数 参考jstack分析cpu负载过高原因： https://blog.csdn.net/u010248330/article/details/80080605 jstack: Java占用高CPU分析之- GC Task Thread: https://blog.csdn.net/chenxiusheng/article/details/74007040]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSTACK 分析线程]]></title>
    <url>%2F2019%2F02%2F11%2Fjava%2Fjstack-cpu%2F</url>
    <content type="text"><![CDATA[查找 tomcat 线程可以通过两种方式找： jps 一般Bootstrap都是tomcat的 ps -ef |grep tomcat jstack dump 出线程1jstack 23524 &gt; jstack.txt 查看 tomcat 内部线程1top -H -p 23524 （shift+p 按 cpu 排序，shift+m 按内存排序） 将PID换算成16进制，然后在jstack.txt查找nid=0x换算后的数1cat jstack.txt | grep 'nid=0x5be9' -B 5 -A 40 可以看出是JNI的问题，一般就是tomcat jni没配置连接池参数导致的了 加上连接池参数 参考jstack分析cpu负载过高原因： https://blog.csdn.net/u010248330/article/details/80080605 jstack: Java占用高CPU分析之- GC Task Thread: https://blog.csdn.net/chenxiusheng/article/details/74007040]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 传入参数为 List、Array、Map]]></title>
    <url>%2F2019%2F02%2F08%2Fjava%2Fmybatis%2Fmybatis-collection-params%2F</url>
    <content type="text"><![CDATA[foreach 标签简单介绍主要用于在SQL语句中构建循环体 标签的主要属性有 item，index，collection，open，separator，close。 属性 描述 item 集合中每一个元素进行迭代时的别名。该参数为必选。 index 指定一个名字，用于表示在迭代过程中，没错迭代到的位置 open 表示该语句以什么开始 close 表示该语句以什么结束 separator 表示在每次进行迭代之间以什么符号作为分隔符 collection 属性是在使用foreach的时候最关键的也是最容易出错的，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况： (1) 如果传入的是单参数且参数类型是一个List的时候，collection属性值为list .(2) 如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array .(3) 如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key.(4) 如果参数使用了@Param注解，那必须是参数名 示例建表语句1234567891011121314151617181920212223242526272829DROP TABLE IF EXISTS `XXGL_CODE_COMBINATIONS`;CREATE TABLE `XXGL_CODE_COMBINATIONS`( `COMBINATION_ID` bigint AUTO_INCREMENT NOT NULL COMMENT '表ID，主键，供其他表做外键' , `CODE_COMBINATION_ID` bigint NOT NULL , `ENABLED_FLAG` varchar(1) NOT NULL COMMENT 'Y/N' , `ACCOUNT_TYPE` varchar(10) NOT NULL COMMENT '账户类型' , `SEGMENT1` varchar(25) NULL COMMENT '段值1', `SEGMENT2` varchar(25) NULL COMMENT '段值2', `SEGMENT3` varchar(25) NULL COMMENT '段值3', `SEGMENT4` varchar(25) NULL COMMENT '段值4', `SEGMENT5` varchar(25) NULL COMMENT '段值5', `SEGMENT6` varchar(25) NULL COMMENT '段值6', `SEGMENT7` varchar(25) NULL COMMENT '段值7', `SEGMENT8` varchar(25) NULL COMMENT '段值8', `SEGMENT9` varchar(25) NULL COMMENT '段值9', `SEGMENT10` varchar(25) NULL COMMENT '段值10', `SEGMENT11` varchar(25) NULL COMMENT '段值11', `SEGMENT12` varchar(25) NULL COMMENT '段值12', `SEGMENT13` varchar(25) NULL COMMENT '段值13', `SEGMENT14` varchar(25) NULL COMMENT '段值14', `SEGMENT15` varchar(25) NULL COMMENT '段值15', `SEGMENT16` varchar(25) NULL COMMENT '段值16', `SEGMENT17` varchar(25) NULL COMMENT '段值17', `SEGMENT18` varchar(25) NULL COMMENT '段值18', PRIMARY KEY (`COMBINATION_ID`), UNIQUE KEY `XXGL_CODE_COMBINATIONS_U1` (`COMBINATION_ID`), KEY `XXGL_CODE_COMBINATIONS_N1` (`CODE_COMBINATION_ID`)) ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8; 测试数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647INSERT INTO `XXGL_CODE_COMBINATIONS` ( `CODE_COMBINATION_ID`, `ENABLED_FLAG`, `ACCOUNT_TYPE`, `SEGMENT1`, `SEGMENT2`, `SEGMENT3`, `SEGMENT4`, `SEGMENT5`, `SEGMENT6`, `SEGMENT7`, `SEGMENT8`, `SEGMENT9`, `SEGMENT10`, `SEGMENT11`, `SEGMENT12`, `SEGMENT13`, `SEGMENT14`, `SEGMENT15`, `SEGMENT16`, `SEGMENT17`, `SEGMENT18`)VALUES ( 300000003238305, 'Y', 'E', '050', '0', '71205', 'S101005', '50010', '1101', 'I101', '0', '0', '0', '0', '0', NULL, NULL, NULL, NULL, NULL, NULL ); 实体类（CodeCombinations.java）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import javax.persistence.GeneratedValue;import javax.persistence.Id;import org.hibernate.validator.constraints.Length;import javax.persistence.Table;import javax.validation.constraints.NotNull;/** * Created by xiaofeng.he on 2018/03/08 * 帐号组合DTO */@Table(name = "XXGL_CODE_COMBINATIONS")public class CodeCombinations &#123; @Id @GeneratedValue private Long combinationId; // 表ID，主键，供其他表做外键 @NotNull private Long codeCombinationId; // ERP中CODE_COMBINATION_ID private String accountType; private String enabledFlag; @Length(max = 25) private String segment1; @Length(max = 25) private String segment2; @Length(max = 25) private String segment3; @Length(max = 25) private String segment4; @Length(max = 25) private String segment5; @Length(max = 25) private String segment6; @Length(max = 25) private String segment7; @Length(max = 25) private String segment8; @Length(max = 25) private String segment9; @Length(max = 25) private String segment10; @Length(max = 25) private String segment11; @Length(max = 25) private String segment12; @Length(max = 25) private String segment13; @Length(max = 25) private String segment14; @Length(max = 25) private String segment15; @Length(max = 25) private String segment16; @Length(max = 25) private String segment17; @Length(max = 25) private String segment18; // getter setter...&#125; java mapper123456789101112131415161718192021222324252627282930import org.apache.ibatis.annotations.Param;/** * Created by xiaofeng.he on 2018/03/08 * 账户组合mapper */public interface CodeCombinationsMapper &#123; /** * 根据多个 segment value 查询唯一 * @param segmentValues * @return */ CodeCombinations selectOneBySegmentArray(@Param("segmentValues") String[] segmentValues); /** * 根据多个 segment value 查询唯一 * @param segmentValues * @return */ CodeCombinations selectOneBySegmentList(List&lt;String&gt; segmentValues); /** * 根据多个 segment value 查询唯一 * @param params * @return */ CodeCombinations selectOneBySegmentMap(Map&lt;String, Object&gt; params);&#125; xml mapper1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="xxx.mapper.CodeCombinationsMapper"&gt; &lt;resultMap id="BaseResultMap" type="xxx.dto.CodeCombinations"&gt; &lt;result column="COMBINATION_ID" property="combinationId" jdbcType="DECIMAL" /&gt; &lt;result column="CODE_COMBINATION_ID" property="codeCombinationId" jdbcType="DECIMAL" /&gt; &lt;result column="ACCOUNT_TYPE" property="accountType" jdbcType="VARCHAR" /&gt; &lt;result column="ENABLED_FLAG" property="enabledFlag" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT1" property="segment1" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT2" property="segment2" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT3" property="segment3" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT4" property="segment4" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT5" property="segment5" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT6" property="segment6" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT7" property="segment7" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT8" property="segment8" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT9" property="segment9" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT10" property="segment10" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT11" property="segment11" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT12" property="segment12" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT13" property="segment13" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT14" property="segment14" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT15" property="segment15" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT16" property="segment16" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT17" property="segment17" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT18" property="segment18" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;!--Array:forech 中的 collection 属性类型是 Array, collection 的值必须是:array, item 的值可以随意, mapper 接口中参数名字随意 --&gt; &lt;select id="selectOneBySegmentArray" resultMap="BaseResultMap"&gt; select c.* from XXGL_CODE_COMBINATIONS c &lt;where&gt; and c.ENABLED_FLAG = 'Y' &lt;choose&gt; &lt;when test="segmentValues"&gt; &lt;!-- 使用了@Param 后collection不能填array，要填写别名 --&gt; &lt;foreach collection="segmentValues" item="segmentValue" index="index"&gt; and c.SEGMENT$&#123;index+1&#125; = #&#123;segmentValue&#125; &lt;/foreach&gt; &lt;/when&gt; &lt;otherwise&gt; and 1=2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; &lt;!--List:forech 中的 collection 属性类型是 List, collection 的值必须是:list, item 的值可以随意, mapper 接口中参数名字随意 --&gt; &lt;select id="selectOneBySegmentList" resultMap="BaseResultMap"&gt; select c.* from XXGL_CODE_COMBINATIONS c &lt;where&gt; and c.ENABLED_FLAG = 'Y' &lt;choose&gt; &lt;when test="list"&gt; &lt;foreach collection="list" item="segmentValue" index="index"&gt; and c.SEGMENT$&#123;index+1&#125; = #&#123;segmentValue&#125; &lt;/foreach&gt; &lt;/when&gt; &lt;otherwise&gt; and 1=2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; &lt;!--Map:不单单 forech 中的 collection 属性是 map.key,其它所有属性都是 map.key, 比如下面的 enabledFlag --&gt; &lt;select id="selectOneBySegmentMap" resultMap="BaseResultMap"&gt; select c.* from XXGL_CODE_COMBINATIONS c &lt;where&gt; and c.ENABLED_FLAG = #&#123;enabledFlag&#125; &lt;choose&gt; &lt;when test="segmentArray"&gt; &lt;foreach collection="segmentArray" item="segmentValue" index="index"&gt; and c.SEGMENT$&#123;index+1&#125; = #&#123;segmentValue&#125; &lt;/foreach&gt; &lt;/when&gt; &lt;otherwise&gt; and 1=2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;choose&gt; &lt;when test="segmentList"&gt; &lt;foreach collection="segmentList" item="segmentValue" index="index"&gt; /* 2 */ and c.SEGMENT$&#123;index+1&#125; = #&#123;segmentValue&#125; &lt;/foreach&gt; &lt;/when&gt; &lt;otherwise&gt; and 1=2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 测试 controller123456789101112131415161718192021222324252627282930313233import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;import xxx.dto.CodeCombinations;import xxx.mapper.CodeCombinationsMapper;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;@Controllerpublic class TestController &#123; @Autowired private CodeCombinationsMapper codeCombinationsMapper; @GetMapping("/test/code/combination/selectBySegments") @ResponseBody public List&lt;CodeCombinations&gt; test() &#123; String[] a = &#123;"050", "0", "71205", "S101005", "50010", "1101", "I101"&#125;; CodeCombinations codeCombinations1 = codeCombinationsMapper.selectOneBySegments(a); CodeCombinations codeCombinations2 = codeCombinationsMapper.selectOneBySegmentList(Arrays.asList(a)); Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put("enabledFlag", "Y"); params.put("segmentArray", a); params.put("segmentList", Arrays.asList(a)); CodeCombinations codeCombinations3 = codeCombinationsMapper.selectOneBySegmentMap(params); return Arrays.asList(codeCombinations1, codeCombinations2, codeCombinations3); &#125;&#125; 测试结果log 12345678910112019-02-08 22:40:40.523 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegments - ==&gt; Preparing: select c.* from XXGL_CODE_COMBINATIONS c WHERE c.ENABLED_FLAG = 'Y' and c.SEGMENT1 = ? and c.SEGMENT2 = ? and c.SEGMENT3 = ? and c.SEGMENT4 = ? and c.SEGMENT5 = ? and c.SEGMENT6 = ? and c.SEGMENT7 = ? 2019-02-08 22:40:40.524 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegments - ==&gt; Parameters: 050(String), 0(String), 71205(String), S101005(String), 50010(String), 1101(String), I101(String)2019-02-08 22:40:40.532 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegments - &lt;== Total: 12019-02-08 22:40:43.259 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentList - ==&gt; Preparing: select c.* from XXGL_CODE_COMBINATIONS c WHERE c.ENABLED_FLAG = 'Y' and c.SEGMENT1 = ? and c.SEGMENT2 = ? and c.SEGMENT3 = ? and c.SEGMENT4 = ? and c.SEGMENT5 = ? and c.SEGMENT6 = ? and c.SEGMENT7 = ? 2019-02-08 22:40:43.259 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentList - ==&gt; Parameters: 050(String), 0(String), 71205(String), S101005(String), 50010(String), 1101(String), I101(String)2019-02-08 22:40:43.263 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentList - &lt;== Total: 12019-02-08 22:40:44.284 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentMap - ==&gt; Preparing: select c.* from XXGL_CODE_COMBINATIONS c WHERE c.ENABLED_FLAG = ? and c.SEGMENT1 = ? and c.SEGMENT2 = ? and c.SEGMENT3 = ? and c.SEGMENT4 = ? and c.SEGMENT5 = ? and c.SEGMENT6 = ? and c.SEGMENT7 = ? /* 2 */ and c.SEGMENT1 = ? /* 2 */ and c.SEGMENT2 = ? /* 2 */ and c.SEGMENT3 = ? /* 2 */ and c.SEGMENT4 = ? /* 2 */ and c.SEGMENT5 = ? /* 2 */ and c.SEGMENT6 = ? /* 2 */ and c.SEGMENT7 = ? 2019-02-08 22:40:44.284 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentMap - ==&gt; Parameters: Y(String), 050(String), 0(String), 71205(String), S101005(String), 50010(String), 1101(String), I101(String), 050(String), 0(String), 71205(String), S101005(String), 50010(String), 1101(String), I101(String)2019-02-08 22:40:44.289 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentMap - &lt;== Total: 1 json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374[&#123;"combinationId": 1000,"codeCombinationId": 300000003238305,"accountType": "E","enabledFlag": "Y","segment1": "050","segment2": "0","segment3": "71205","segment4": "S101005","segment5": "50010","segment6": "1101","segment7": "I101","segment8": "0","segment9": "0","segment10": "0","segment11": "0","segment12": "0","segment13": null,"segment14": null,"segment15": null,"segment16": null,"segment17": null,"segment18": null&#125;,&#123;"combinationId": 1000,"codeCombinationId": 300000003238305,"accountType": "E","enabledFlag": "Y","segment1": "050","segment2": "0","segment3": "71205","segment4": "S101005","segment5": "50010","segment6": "1101","segment7": "I101","segment8": "0","segment9": "0","segment10": "0","segment11": "0","segment12": "0","segment13": null,"segment14": null,"segment15": null,"segment16": null,"segment17": null,"segment18": null&#125;,&#123;"combinationId": 1000,"codeCombinationId": 300000003238305,"accountType": "E","enabledFlag": "Y","segment1": "050","segment2": "0","segment3": "71205","segment4": "S101005","segment5": "50010","segment6": "1101","segment7": "I101","segment8": "0","segment9": "0","segment10": "0","segment11": "0","segment12": "0","segment13": null,"segment14": null,"segment15": null,"segment16": null,"segment17": null,"segment18": null&#125;] 感谢https://blog.csdn.net/s592652578/article/details/52871884]]></content>
      <categories>
        <category>Java</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[航天信息金税盘接口 js 调用]]></title>
    <url>%2F2018%2F12%2F02%2Fessay%2Fgold-tax-js%2F</url>
    <content type="text"><![CDATA[背景 最近项目要求与单机版的金税盘接口进行对接，在这里简单记录一下自己的开发经验，希望可以帮助到有需要的人 PS：接口使用 js 对接，仅支持 ie 浏览器。 前置条件在进行开发时候需要有一些前置条件 ie 浏览器 开启 activeX 控件 设置 –&gt; Internet 选项 –&gt; 安全 –&gt; 自定义级别 把 activeX 相关设置勾上 可参考: 管理员身份运行调试 如果开票软件安装到本地 C盘 需要使用管理员打开 ie 浏览器，然后再进行调试 金税盘安装 要确保金税盘安装准确安装了TaxCardX.dll 通用 js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395/** 航信金税盘相关function */var goldTax = &#123; /** * 使用前先判断是否是ie浏览器 * @return true/false */ isIE: function () &#123; if(!!window.ActiveXObject || "ActiveXObject" in window) return true; else return false; &#125;, /** * 开启金税盘 * @param certPassword 单机版为证书口令 服务器版为地址 留空则读取开票BIN文件下cert.txt * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx', // 错误信息 * 'data': &#123;&#125; // 接口返回相关数据 * &#125; * &lt;/pre&gt; */ openCard: function (certPassword) &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '', 'data': &#123;&#125; &#125;; try &#123; goldTax.card = new ActiveXObject("TaxCardX.GoldTax"); // 单机版为证书口令 服务器版为地址 留空则读取开票BIN文件下cert.txt if(typeof certPassword != 'undefined') &#123; goldTax.card.CertPassword = certPassword; &#125; // 开启金税盘 goldTax.card.OpenCard(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // 1011 开启成功 if (result.code == 1011) &#123; result.success = true; result.data = &#123; RetCode: goldTax.card.RetCode, /* RetCode - 状态码， 1011 开启成功 */ RetMsg: goldTax.card.RetMsg, /* RetMsg 状态信息 */ InvLimit: goldTax.card.InvLimit, /* InvLimit – 开票限额, 金税卡发票开具价税合计限额 */ TaxCode: goldTax.card.TaxCode, /* TaxCode 本单位税号 */ TaxClock: goldTax.card.TaxClock, /* TaxClock – 金税卡时钟 */ MachineNo: goldTax.card.MachineNo, /* MachineNo – 开票机号码，主开票机为 0 */ IsInvEmpty: goldTax.card.IsInvEmpty, /* IsInvEmpty – 有票标志，0为金税卡中无可开发票，1为有票 */ IsRepReached: goldTax.card.IsRepReached, /* IsRepReached – 抄税标志，0为未到抄税期，1为已到抄税期 */ IsLockReached: goldTax.card.IsLockReached, /* IsLockReached – 锁死标志，0为未到锁死期，1为已到锁死期 */ &#125;; &#125; else &#123; result.success = false; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125;, /** * 关闭金税盘 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx' // 错误信息 * &#125; * &lt;/pre&gt; */ closeCard: function() &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '' &#125;; if (typeof goldTax.card != 'undefined') &#123; try &#123; goldTax.card.closeCard(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // RetCode 9000 调用成功，其他失败 if (result.code == 9000) &#123; result.success = true; &#125; else &#123; result.success = false; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125; &#125;, /** * 查询库存发票 * @param invKind 发票种类 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx', // 错误信息 * 'data': &#123;&#125; // 接口返回相关数据 * &#125; * &lt;/pre&gt; */ invoiceInventory: function(invKind) &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '', 'data': &#123;&#125; &#125;; try &#123; if (typeof goldTax.card != 'undefined') &#123; goldTax.card.InfoKind = invKind; goldTax.card.GetInfo(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // RetCode 3011 读取成功，其他失败 if (result.code == 3011) &#123; result.success = true; result.data = &#123; RetCode: goldTax.card.RetCode, /* RetCode - 状态码， 3011 读取成功，其他失败 */ RetMsg: goldTax.card.RetMsg, /* RetMsg 状态信息 */ InfoTypeCode: goldTax.card.InfoTypeCode, /* 要开具发票的十位代码。为空或全为0时，表示无可用发票 */ InfoNumber: goldTax.card.InfoNumber, /* 要开具发票的号码 */ InvStock: goldTax.card.InvStock, /* 剩余的可用发票份数 */ TaxClock: goldTax.card.TaxClock /* 金税盘时钟 */ &#125;; &#125; else &#123; result.success = false; &#125; &#125; else &#123; result.success = false; result.code = -1; result.msg = 'Please Open Card First'; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125;, /** * 发票校验 * @param o 传入发票信息 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx', // 错误信息 * 'data': &#123;&#125; // 接口返回相关数据 * &#125; * &lt;/pre&gt; */ invoiceVeriferify: function(o) &#123; return goldTax.inner.invoice(1, o); &#125;, /** * 发票开具 * @param o 传入发票信息 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx', // 错误信息 * 'data': &#123;&#125; // 接口返回相关数据 * &#125; * &lt;/pre&gt; */ invoicing: function(o) &#123; return goldTax.inner.invoice(0, o); &#125;, /** * 发票打印 * @param o 传入发票信息 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx' // 错误信息 * &#125; * &lt;/pre&gt; */ printInv: function(o) &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '' &#125;; try &#123; if (typeof goldTax.card != 'undefined') &#123; goldTax.card.InfoKind = o.InfoKind; /* 发票种类（0：专用发票 2：普通发票 11：货物运输业增值税专用发票 12：机动车销售统一发票） */ goldTax.card.InfoTypeCode = o.InfoTypeCode; /* 要打印发票的十位代码 */ goldTax.card.InfoNumber = o.InfoNumber; /* 要打印发票的号码 */ goldTax.card.GoodsListFlag = o.GoodsListFlag; /* 销货清单标志，0 – 打印发票，1 – 打印销货清单 */ goldTax.card.InfoShowPrtDlg = o.InfoShowPrtDlg; /* 打印时是否显示边距确认对话框，0 – 不出现，1 – 出现 */ // 调用接口 goldTax.card.PrintInv(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // RetCode 5011 打印成功，5001 – 未找到发票或清单，5012 – 未打印，5013 – 打印失败 if (result.code == 5011) &#123; result.success = true; &#125; else &#123; result.success = false; &#125; &#125; else &#123; result.success = false; result.code = -1; result.msg = 'Please Open Card First'; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125;, /** * 已开发票作废 * @param o 传入发票信息 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx' // 错误信息 * &#125; * &lt;/pre&gt; */ cancelInv: function(o) &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '' &#125;; try &#123; if (typeof goldTax.card != 'undefined') &#123; goldTax.card.InfoKind = o.InfoKind; /* 发票种类（0：专用发票 2：普通发票 11：货物运输业增值税专用发票 12：机动车销售统一发票） */ goldTax.card.InfoTypeCode = o.InfoTypeCode; /* 要作废发票的十位或十二位代码 */ goldTax.card.InfoNumber = o.InfoNumber; /* 要作废发票的号码 */ // 调用接口 goldTax.card.CancelInv(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // RetCode 6011 打印成功，6001 – 当月发票库未找到该发票，6002 – 该发票已经作废，6012 – 作废失败，6013 – 作废失败(异常) if (result.code == 6011) &#123; result.success = true; &#125; else &#123; result.success = false; &#125; &#125; else &#123; result.success = false; result.code = -1; result.msg = 'Please Open Card First'; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125;, // 内部方法 inner: &#123; /** * invoice 接口 * @param checkEWM 默认为0（0: 发票开具, 1: 发票校验, 2: 空白作废) * @param o 传入发票信息 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx', // 错误信息 * 'data': &#123;&#125; // 接口返回相关数据 * &#125; * &lt;/pre&gt; */ invoice: function(checkEWM, o) &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '', 'data': &#123;&#125; &#125;; try &#123; if (typeof goldTax.card != 'undefined') &#123; // CheckEWM值默认为0（为1时用于发票校验。 // 注意：一旦CheckEWM值置1用于发票校验之后， //如果要再进行发票开具必须手动将CheckEWM值置为0，否则Invoice()方法的功能将一直处于发票校验状态） goldTax.card.CheckEWM = checkEWM; goldTax.card.InvInfoInit(); /* 初始化发票抬头信息 */ goldTax.card.InfoKind = o.InfoKind; /* 增值税普通发票2 专票0 */ goldTax.card.InfoClientName = o.InfoClientName; /* 购方名称 */ goldTax.card.InfoClientTaxCode = o.InfoClientTaxCode; /* 购方税号 */ goldTax.card.InfoClientBankAccount = o.InfoClientBankAccount; /* 购方开户行及账号 */ goldTax.card.InfoClientAddressPhone = o.InfoClientAddressPhone; /* 购方地址电话 */ goldTax.card.InfoSellerBankAccount = o.InfoSellerBankAccount; /* 销方开户行及账号 */ goldTax.card.InfoSellerAddressPhone = o.InfoSellerAddressPhone; /* 销方地址电话 */ // 如果是多商品多税率 税率应该放到下面商品信息循环里 if (typeof o.InfoTaxRate != 'undefined' &amp;&amp; o.InfoTaxRate) &#123; goldTax.card.InfoTaxRate = o.InfoTaxRate; /* 税率,(已授权的税率， 17% 传17) */ &#125; goldTax.card.InfoNotes = o.InfoNotes; /* 备注 */ goldTax.card.InfoInvoicer = o.InfoInvoicer; /* 开票人 */ // 复核人，可为空 if (typeof o.InfoChecker != 'undefined' &amp;&amp; o.InfoChecker) &#123; goldTax.card.InfoChecker = o.InfoChecker; &#125; // 收款人，可为空 if (typeof o.InfoCashier != 'undefined' &amp;&amp; o.InfoCashier) &#123; goldTax.card.InfoCashier = o.InfoCashier; &#125; // 如不为空，则开具销货清单，此为发票上商品名称栏的清单信息，应为“(详见销货清单)”字样 if (typeof o.InfoListName != 'undefined' &amp;&amp; o.InfoListName) &#123; goldTax.card.InfoListName = o.InfoListName; &#125; // 清空商品明细列表 goldTax.card.ClearInvList(); // 遍历行 $.each(o.InvList, function(i, v) &#123; goldTax.card.InvListInit(); /* 初始化发票明细信息各项属性 */ goldTax.card.ListGoodsName = v.ListGoodsName; /* 商品或劳务名称 */ goldTax.card.ListTaxItem = v.ListTaxItem; /* 税目，4位数字，商品所属类别 */ goldTax.card.ListStandard = v.ListStandard; /* 规格型号 */ // 计量单位，如计量单位为空，则忽略数量和单价 if (typeof v.ListUnit != 'undefined' &amp;&amp; v.ListUnit) &#123; goldTax.card.ListUnit = v.ListUnit; &#125; // 建议传入数量和含税单价或含税金额 由接口计算带小数的税额 规避误差 goldTax.card.ListNumber = v.ListNumber; // 数量 goldTax.card.ListPrice = v.ListPrice; // 单价 // 金额，可以不传(为0)，由接口软件计算，如传入则应符合计算关系 if (typeof v.ListAmount != 'undefined' &amp;&amp; v.ListAmount ) &#123; goldTax.card.ListAmount = v.ListAmount; &#125; goldTax.card.ListPriceKind = v.ListPriceKind; /* 含税价标志，单价和金额的种类， 0为不含税价，1为含税价 */ // 税额可以不传(为0)，由接口软件计算，如传入则应符合计算关系 if (typeof v.ListTaxAmount != 'undefined' &amp;&amp; v.ListTaxAmount) &#123; goldTax.card.ListTaxAmount = v.ListTaxAmount; &#125; // 添加一行 goldTax.card.AddInvList(); &#125;); // 调用接口 goldTax.card.Invoice(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // RetCode 4011 开票成功，其他失败 if (result.code == 4011) &#123; result.success = true; result.data = &#123; RetCode: goldTax.card.RetCode, /* RetCode - 状态码， 3011 读取成功，其他失败 */ RetMsg: goldTax.card.RetMsg, /* RetMsg 状态信息 */ InfoAmount: goldTax.card.InfoAmount , /* 合计不含税金额 */ InfoTaxAmount: goldTax.card.InfoTaxAmount, /* 合计税额 */ InfoInvDate: goldTax.card.InfoInvDate, /* 开票日期 */ InfMonth: goldTax.card.InfMonth, /* 所属月份 */ InfoTypeCode: goldTax.card.InfoTypeCode, /* 发票十位代码 */ InfoNumber: goldTax.card.InfoNumber, /* 发票号码 */ GoodsListFlag: goldTax.card.GoodsListFlag /* 销货清单标志，0 – 无销货清单，1 – 有销货清单 */ &#125;; &#125; else &#123; result.success = false; &#125; &#125; else &#123; result.success = false; result.code = -1; result.msg = 'Please Open Card First'; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125; &#125;&#125;; 相关资料CSDN 需要积分下载 金税 防伪税控 组件接口 开发文档 代码案例 没有积分的 戳这里]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ActiveX</tag>
        <tag>金税</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
