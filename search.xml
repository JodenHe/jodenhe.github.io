<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ADFS 安装及配置]]></title>
    <url>%2F2019%2F03%2F11%2Fsso%2Fadfs%2Fadfs-install%2F</url>
    <content type="text"><![CDATA[安装前准备在安装 ADFS 之前，我们需要准备号 DC，参考 ADDS 活动目录安装详解 安装配置证书服务在 DC 上安装 CA 打开服务器管理器，点击 “添加角色和功能” 保持默认，并连续点击三次“下一步” 勾选 “Active Directory 证书服务”，然后选择添加所需的功能，最后点“下一步”继续 功能选择页面保持默认，连续点击2次“下一步” 勾选 CA 相关服务, 一直点下一步，最后点击安装 安装完成 配置证书服务 CA 安装完成后，如图点击提示图标后，选择“配置目标服务器上的 Active Directory 证书服务” 根据向导进行配置 勾选所需要配置的服务 选择企业根 创建新的私钥 指定 CA 名称 指定有效期 指定数据库位置 确认配置信息 配置完成 验证 CA 以上环境准备好后就可以配置 ADFS 服务器了。在配置前我们需要给计算机或者指定的用户或者计算机授权证书颁发。 安装ADFS服务在安装 ADFS 之前，我们需要创建和配置证书 创建证书账户准备好后，然后申请证书，其实有很常见的两种方法，第一种就是通过iis进行证书申请，第二种通过 mmc 控制台进行申请，这里使用IIS的申请方法。 打开IIS管理器，选择【服务器证书】创建证书申请 保存到桌面上：cert.txt 配置证书 服务器浏览器，输入 http://127.0.0.1/certsrv/ 如下： 选择申请证书——&gt;高级证书申请 选择： 使用 base64 编码的 CMC 或 PKCS #10 文件提交 一个证书申请，或使用 base64 编码的 PKCS #7 文件续订证书申请 打开cert.txt ，粘贴进去，证书模板选择 web服务器，提交 下载证书，保存到本地： 回到iis管理器，选择完成证书申请 将 default web site 的 https 绑定证书改为刚才完成的证书 选择 default web site , 右键 编辑绑定，选择 https（没有则添加） ， 点击编辑，选择 ssl 证书:（ 这个证书在安装adfs时使用该证书） 开始安装 打开服务器管理器，点击 “添加角色和功能” 保持默认，并连续点击三次“下一步” 勾选 “Active Directory Federation Services” 安装服务角色 功能选择页面保持默认，连续点击2次“下一步” 安装 安装完成 ADFS 安装完成后，如图点击提示图标后，选择“在此服务器上配置联合身份验证服务” 功能选择页面保持默认，连续点击2次“下一步” 选择证书(不是前面创建的证书)，填写显示的名称 选择 adfs 服务帐号 指定配置数据库 下一步 配置 配置完成 至此 ADFS 安装配置完成 参考Windows Server 2016 安装及配置 ADFS 4.0 Server2012 下 部署adfs IFD]]></content>
      <categories>
        <category>SSO</category>
        <category>ADFS</category>
      </categories>
      <tags>
        <tag>SSO</tag>
        <tag>ADFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADDS 活动目录安装详解]]></title>
    <url>%2F2019%2F03%2F09%2Fsso%2Fadfs%2Fadds-install%2F</url>
    <content type="text"><![CDATA[安装前准备确保域控制器 (DC) 的计算机名符合企业命名规范，因为 AD 安装完成后再更改 DC 计算机相对复杂而且存在风险。DC 需要使用固定的静态IP地址，并且把DNS设置指向本机IP。 这台电脑 (右键) –&gt; 属性，更改设置： 网络 (右键) –&gt; 属性 –&gt; 以太网 –&gt; 属性 –&gt; Internet 协议版本 4（TCP/IPV4） –&gt; 属性 开始安装 打开服务器管理器，点击 “添加角色和功能” 保持默认，并连续点击三次“下一步”。 勾选 “ActiveDirectory域服务”，然后选择添加所需的功能，最后点“下一步”继续。 功能选择页面保持默认，连续点击2次“下一步”。 勾选自动重启服务器，点击“安装”。 完成ADDS安装后，如图点击提示图标后，选择“将此服务器提升为域控制器”。 由于这是第一台域控制器(DC)，也叫林根域。选择“添加新林”，然后输入根域名。 选择林和域功能级别，勾选DNS(AD需要高度集成DNS)，并输入目录还原模式密码。 由于现在还没有DNS服务器，所以会提示无法创建委派。直接“下一步”。 NetBIOS名以及ADDS数据库、日志、Sysvol保存位置，如果企业没有特殊要求，一般保持默认即可。 检查配置无误后点击“下一步”，然后点击“安装”，等待安装完成后重启即可。 至此完成 ActiveDirectory 的全部安装。已经可以对外提供服务了。 参考Active Directory管理之一:活动目录安装详解]]></content>
      <categories>
        <category>SSO</category>
        <category>ADFS</category>
      </categories>
      <tags>
        <tag>SSO</tag>
        <tag>ADFS</tag>
        <tag>ADDS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转载] 获取被代理类的真实类]]></title>
    <url>%2F2019%2F03%2F07%2FJava%2Fspring%2Ftarget-class%2F</url>
    <content type="text"><![CDATA[版权说明，文章转载自 Spring 笔记-获取被代理的真实类 对一个 Autowired 进来的类调用 getClass，发现得到的类是: com.xxx.search.provider.service.SearchServiceImpl$$EnhancerBySpringCGLIB$$129db519，一看就不是正经类。从名字中可以看出，这个是被代理后的类，可能因为这个类被AOP了吧。但是我在反射操作是需要原始的类的信息，要如何得到呢？ org.springframework.aop 下有一个很重要的接口: TargetClassAware, 这个接口表示目前这个类是被代理的。所以我们可以通过判断一个实例是否是 TargetClassAware 的实例来判断他是否是一个代理类。而且 TargetClassAware 接口提供了 getTargetClass 方法来获取真实类。可以这么用： 123if (aInstance instanceof TargetClassAware) &#123; aInstance.getTargetClass();&#125; 不过更推荐的做法是使用 org.springframework.aop.support.AopUtils 提供的 getTargetClass 方法来获取真实类。可以看看其源码： 12345678910111213public static Class&lt;?&gt; getTargetClass(Object candidate) &#123; Assert.notNull(candidate, "Candidate object must not be null"); Class result = null; if(candidate instanceof TargetClassAware) &#123; result = ((TargetClassAware)candidate).getTargetClass(); &#125; if(result == null) &#123; result = isCglibProxy(candidate)?candidate.getClass().getSuperclass():candidate.getClass(); &#125; return result;&#125; 代码首先判断当前类是否是 TargetClassAware 的实现，如果是，调用 getTargetClass，方法还判断当前类是否是 CglibProxy，如果是基于 cglib 的代理类，因为是基于继承来实现代理，所以获取父类就是真实类了。 参考资料 java - Obtain real Class object for Spring bean - Stack Overflow AopUtils)]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle cloud 如何获取图片 url]]></title>
    <url>%2F2019%2F02%2F20%2Foracle-cloud%2Fhow-to-get-image-url%2F</url>
    <content type="text"><![CDATA[以获取物料图片 url 作为例子 123456789101112(SELECT (decode(datatype_code, 'FILE', (:p_host || '/cs/idcplg?IdcService=GET_FILE&amp;dID=') || dm_version_number, 'WEB_PAGE', url)) AS image FROM fnd_attached_documents d, fnd_documents_vl dv WHERE d.document_id = d.document_id AND d.entity_name = 'ITEM_ENTITY' AND d.pk1_value = to_char(esi.organization_id) AND d.pk2_value = to_char(esi.inventory_item_id) AND rownum = 1) AS item_photo 其中 p_host 为 cloud 的主域名 其他类型的图片 url 可以通过变换 d.entity_name = &#39;ITEM_ENTITY&#39; 进行查找]]></content>
      <categories>
        <category>Oracle Cloud</category>
      </categories>
      <tags>
        <tag>Oracle Cloud</tag>
        <tag>attachment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何获取 oracle cloud 的 PO 的 shipping method]]></title>
    <url>%2F2019%2F02%2F20%2Foracle-cloud%2Fpo%2Fhow-to-get-shipping-method%2F</url>
    <content type="text"><![CDATA[版本信息example12345678910111213SELECT po_bip_helper.get_shipping_method(carrierpartyname.party_name, modeoftransportlookuppeo.meaning, servicelevellookuppeo.meaning) AS shippingmethod FROM wsh_carriers carrier, hz_parties carrierpartyname, fnd_lookups modeoftransportlookuppeo, fnd_lookups servicelevellookuppeo, po_headers_all header WHERE (header.mode_of_transport = modeoftransportlookuppeo.lookup_code(+) AND modeoftransportlookuppeo.lookup_type(+) = 'WSH_MODE_OF_TRANSPORT') AND (header.service_level = servicelevellookuppeo.lookup_code(+) AND servicelevellookuppeo.lookup_type(+) = 'WSH_SERVICE_LEVELS') AND header.carrier_id = carrier.carrier_id(+) AND carrier.carrier_id = carrierpartyname.party_id(+) AND header.segment1 = '20000028']]></content>
      <categories>
        <category>Oracle Cloud</category>
        <category>PO</category>
      </categories>
      <tags>
        <tag>Oracle Cloud</tag>
        <tag>PO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何获取 oracle cloud 的 Match Approval Level]]></title>
    <url>%2F2019%2F02%2F20%2Foracle-cloud%2Fhow-to-get-match-approval-level%2F</url>
    <content type="text"><![CDATA[版本信息Oracle Cloud Application Revision 13.18.10 (11.13.18.10.0) Title Description Oracle Application Development Framework JDEVADF_11.1.1.9.2ADF-REL131810-PROD-BP_GENERIC_181116.1437.7206 Oracle Middleware Extensions for Applications ATGPF_PT.REL13.18.10_GENERIC_181113.1603.REL13BP16.7 Database Compatibility TRUE (REL13BP16.7) 提示 When Receipt Required Flag is N, then Match Approval level is 2 way. When Receipt Required Flag is Y and Inspection Required Flag is N, then Match Approval Level is 3 way. When Receipt Required Flag is Y and Inspection Required Flag is Y, then Match Approval Level is 4 way. 2-way 不需要检测收货 receipt_required_flag 为 N 3-way 需要在 match invoice 的时候验收货 所以 receipt_required_flag 为Y , inspection_required_flag 为 N 4-way 还要检测验货 所以 两个都为 Y SQL123456789decode(poz_supplier_sites_v.receipt_required_flag, 'Y', decode(poz_supplier_sites_v.inspection_required_flag, 'Y', '4-Way', 'N', '3-Way'), 'N', '2-Way') AS matching_level 参考http://j178.mtgbb.com/?p=713]]></content>
      <categories>
        <category>Oracle Cloud</category>
      </categories>
      <tags>
        <tag>Oracle Cloud</tag>
        <tag>Match Approval Level</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitlab 更新 fork 的代码]]></title>
    <url>%2F2019%2F02%2F18%2Fgit%2Fgitlab-update-fork%2F</url>
    <content type="text"><![CDATA[操作步骤 先确定是否建立了主仓库的远程数据源: 1git remote -v 我们发现只有我们自己的两个源(fetch 和 push)，那这个时候就需要添加主仓库的源。 添加主仓库的源 1git remote add upstream URL upstream : 随便起的名字 URL： fork的仓库地址 如果想删除remote的upstream标签，则可以运行： git remote rm upstream 更新代码 123git fetch upstreamgit checkout mastergit merge upstream/master 参考https://blog.csdn.net/lhh1113/article/details/71038154]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSTACK 分析线程]]></title>
    <url>%2F2019%2F02%2F11%2FJava%2Fjstack-cpu%2F</url>
    <content type="text"><![CDATA[查找 tomcat 线程可以通过两种方式找： jps 一般Bootstrap都是tomcat的 ps -ef |grep tomcat jstack dump 出线程1jstack 23524 &gt; jstack.txt 查看 tomcat 内部线程1top -H -p 23524 （shift+p 按 cpu 排序，shift+m 按内存排序） 将PID换算成16进制，然后在jstack.txt查找nid=0x换算后的数1cat jstack.txt | grep 'nid=0x5be9' -B 5 -A 40 发现频繁的GC，推测是不是数据库在频繁的开关导致，因此检查 tomcat jndi是否没配置数据库连接池参数 加上连接池参数 参考jstack分析cpu负载过高原因： https://blog.csdn.net/u010248330/article/details/80080605 jstack: Java占用高CPU分析之- GC Task Thread: https://blog.csdn.net/chenxiusheng/article/details/74007040]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 传入参数为 List、Array、Map]]></title>
    <url>%2F2019%2F02%2F08%2FJava%2FMyBatis%2Fmybatis-collection-params%2F</url>
    <content type="text"><![CDATA[foreach 标签简单介绍主要用于在SQL语句中构建循环体 标签的主要属性有 item，index，collection，open，separator，close。 属性 描述 item 集合中每一个元素进行迭代时的别名。该参数为必选。 index 指定一个名字，用于表示在迭代过程中，没错迭代到的位置 open 表示该语句以什么开始 close 表示该语句以什么结束 separator 表示在每次进行迭代之间以什么符号作为分隔符 collection 属性是在使用foreach的时候最关键的也是最容易出错的，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况： (1) 如果传入的是单参数且参数类型是一个List的时候，collection属性值为list .(2) 如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array .(3) 如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key.(4) 如果参数使用了@Param注解，那必须是参数名 示例建表语句1234567891011121314151617181920212223242526272829DROP TABLE IF EXISTS `XXGL_CODE_COMBINATIONS`;CREATE TABLE `XXGL_CODE_COMBINATIONS`( `COMBINATION_ID` bigint AUTO_INCREMENT NOT NULL COMMENT '表ID，主键，供其他表做外键' , `CODE_COMBINATION_ID` bigint NOT NULL , `ENABLED_FLAG` varchar(1) NOT NULL COMMENT 'Y/N' , `ACCOUNT_TYPE` varchar(10) NOT NULL COMMENT '账户类型' , `SEGMENT1` varchar(25) NULL COMMENT '段值1', `SEGMENT2` varchar(25) NULL COMMENT '段值2', `SEGMENT3` varchar(25) NULL COMMENT '段值3', `SEGMENT4` varchar(25) NULL COMMENT '段值4', `SEGMENT5` varchar(25) NULL COMMENT '段值5', `SEGMENT6` varchar(25) NULL COMMENT '段值6', `SEGMENT7` varchar(25) NULL COMMENT '段值7', `SEGMENT8` varchar(25) NULL COMMENT '段值8', `SEGMENT9` varchar(25) NULL COMMENT '段值9', `SEGMENT10` varchar(25) NULL COMMENT '段值10', `SEGMENT11` varchar(25) NULL COMMENT '段值11', `SEGMENT12` varchar(25) NULL COMMENT '段值12', `SEGMENT13` varchar(25) NULL COMMENT '段值13', `SEGMENT14` varchar(25) NULL COMMENT '段值14', `SEGMENT15` varchar(25) NULL COMMENT '段值15', `SEGMENT16` varchar(25) NULL COMMENT '段值16', `SEGMENT17` varchar(25) NULL COMMENT '段值17', `SEGMENT18` varchar(25) NULL COMMENT '段值18', PRIMARY KEY (`COMBINATION_ID`), UNIQUE KEY `XXGL_CODE_COMBINATIONS_U1` (`COMBINATION_ID`), KEY `XXGL_CODE_COMBINATIONS_N1` (`CODE_COMBINATION_ID`)) ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8; 测试数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647INSERT INTO `XXGL_CODE_COMBINATIONS` ( `CODE_COMBINATION_ID`, `ENABLED_FLAG`, `ACCOUNT_TYPE`, `SEGMENT1`, `SEGMENT2`, `SEGMENT3`, `SEGMENT4`, `SEGMENT5`, `SEGMENT6`, `SEGMENT7`, `SEGMENT8`, `SEGMENT9`, `SEGMENT10`, `SEGMENT11`, `SEGMENT12`, `SEGMENT13`, `SEGMENT14`, `SEGMENT15`, `SEGMENT16`, `SEGMENT17`, `SEGMENT18`)VALUES ( 300000003238305, 'Y', 'E', '050', '0', '71205', 'S101005', '50010', '1101', 'I101', '0', '0', '0', '0', '0', NULL, NULL, NULL, NULL, NULL, NULL ); 实体类（CodeCombinations.java）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import javax.persistence.GeneratedValue;import javax.persistence.Id;import org.hibernate.validator.constraints.Length;import javax.persistence.Table;import javax.validation.constraints.NotNull;/** * Created by xiaofeng.he on 2018/03/08 * 帐号组合DTO */@Table(name = "XXGL_CODE_COMBINATIONS")public class CodeCombinations &#123; @Id @GeneratedValue private Long combinationId; // 表ID，主键，供其他表做外键 @NotNull private Long codeCombinationId; // ERP中CODE_COMBINATION_ID private String accountType; private String enabledFlag; @Length(max = 25) private String segment1; @Length(max = 25) private String segment2; @Length(max = 25) private String segment3; @Length(max = 25) private String segment4; @Length(max = 25) private String segment5; @Length(max = 25) private String segment6; @Length(max = 25) private String segment7; @Length(max = 25) private String segment8; @Length(max = 25) private String segment9; @Length(max = 25) private String segment10; @Length(max = 25) private String segment11; @Length(max = 25) private String segment12; @Length(max = 25) private String segment13; @Length(max = 25) private String segment14; @Length(max = 25) private String segment15; @Length(max = 25) private String segment16; @Length(max = 25) private String segment17; @Length(max = 25) private String segment18; // getter setter...&#125; java mapper123456789101112131415161718192021222324252627282930import org.apache.ibatis.annotations.Param;/** * Created by xiaofeng.he on 2018/03/08 * 账户组合mapper */public interface CodeCombinationsMapper &#123; /** * 根据多个 segment value 查询唯一 * @param segmentValues * @return */ CodeCombinations selectOneBySegmentArray(@Param("segmentValues") String[] segmentValues); /** * 根据多个 segment value 查询唯一 * @param segmentValues * @return */ CodeCombinations selectOneBySegmentList(List&lt;String&gt; segmentValues); /** * 根据多个 segment value 查询唯一 * @param params * @return */ CodeCombinations selectOneBySegmentMap(Map&lt;String, Object&gt; params);&#125; xml mapper1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="xxx.mapper.CodeCombinationsMapper"&gt; &lt;resultMap id="BaseResultMap" type="xxx.dto.CodeCombinations"&gt; &lt;result column="COMBINATION_ID" property="combinationId" jdbcType="DECIMAL" /&gt; &lt;result column="CODE_COMBINATION_ID" property="codeCombinationId" jdbcType="DECIMAL" /&gt; &lt;result column="ACCOUNT_TYPE" property="accountType" jdbcType="VARCHAR" /&gt; &lt;result column="ENABLED_FLAG" property="enabledFlag" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT1" property="segment1" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT2" property="segment2" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT3" property="segment3" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT4" property="segment4" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT5" property="segment5" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT6" property="segment6" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT7" property="segment7" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT8" property="segment8" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT9" property="segment9" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT10" property="segment10" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT11" property="segment11" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT12" property="segment12" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT13" property="segment13" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT14" property="segment14" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT15" property="segment15" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT16" property="segment16" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT17" property="segment17" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT18" property="segment18" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;!--Array:forech 中的 collection 属性类型是 Array, collection 的值必须是:array, item 的值可以随意, mapper 接口中参数名字随意 --&gt; &lt;select id="selectOneBySegmentArray" resultMap="BaseResultMap"&gt; select c.* from XXGL_CODE_COMBINATIONS c &lt;where&gt; and c.ENABLED_FLAG = 'Y' &lt;choose&gt; &lt;when test="segmentValues"&gt; &lt;!-- 使用了@Param 后collection不能填array，要填写别名 --&gt; &lt;foreach collection="segmentValues" item="segmentValue" index="index"&gt; and c.SEGMENT$&#123;index+1&#125; = #&#123;segmentValue&#125; &lt;/foreach&gt; &lt;/when&gt; &lt;otherwise&gt; and 1=2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; &lt;!--List:forech 中的 collection 属性类型是 List, collection 的值必须是:list, item 的值可以随意, mapper 接口中参数名字随意 --&gt; &lt;select id="selectOneBySegmentList" resultMap="BaseResultMap"&gt; select c.* from XXGL_CODE_COMBINATIONS c &lt;where&gt; and c.ENABLED_FLAG = 'Y' &lt;choose&gt; &lt;when test="list"&gt; &lt;foreach collection="list" item="segmentValue" index="index"&gt; and c.SEGMENT$&#123;index+1&#125; = #&#123;segmentValue&#125; &lt;/foreach&gt; &lt;/when&gt; &lt;otherwise&gt; and 1=2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; &lt;!--Map:不单单 forech 中的 collection 属性是 map.key,其它所有属性都是 map.key, 比如下面的 enabledFlag --&gt; &lt;select id="selectOneBySegmentMap" resultMap="BaseResultMap"&gt; select c.* from XXGL_CODE_COMBINATIONS c &lt;where&gt; and c.ENABLED_FLAG = #&#123;enabledFlag&#125; &lt;choose&gt; &lt;when test="segmentArray"&gt; &lt;foreach collection="segmentArray" item="segmentValue" index="index"&gt; and c.SEGMENT$&#123;index+1&#125; = #&#123;segmentValue&#125; &lt;/foreach&gt; &lt;/when&gt; &lt;otherwise&gt; and 1=2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;choose&gt; &lt;when test="segmentList"&gt; &lt;foreach collection="segmentList" item="segmentValue" index="index"&gt; /* 2 */ and c.SEGMENT$&#123;index+1&#125; = #&#123;segmentValue&#125; &lt;/foreach&gt; &lt;/when&gt; &lt;otherwise&gt; and 1=2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 测试 controller123456789101112131415161718192021222324252627282930313233import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;import xxx.dto.CodeCombinations;import xxx.mapper.CodeCombinationsMapper;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;@Controllerpublic class TestController &#123; @Autowired private CodeCombinationsMapper codeCombinationsMapper; @GetMapping("/test/code/combination/selectBySegments") @ResponseBody public List&lt;CodeCombinations&gt; test() &#123; String[] a = &#123;"050", "0", "71205", "S101005", "50010", "1101", "I101"&#125;; CodeCombinations codeCombinations1 = codeCombinationsMapper.selectOneBySegments(a); CodeCombinations codeCombinations2 = codeCombinationsMapper.selectOneBySegmentList(Arrays.asList(a)); Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put("enabledFlag", "Y"); params.put("segmentArray", a); params.put("segmentList", Arrays.asList(a)); CodeCombinations codeCombinations3 = codeCombinationsMapper.selectOneBySegmentMap(params); return Arrays.asList(codeCombinations1, codeCombinations2, codeCombinations3); &#125;&#125; 测试结果log 12345678910112019-02-08 22:40:40.523 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegments - ==&gt; Preparing: select c.* from XXGL_CODE_COMBINATIONS c WHERE c.ENABLED_FLAG = 'Y' and c.SEGMENT1 = ? and c.SEGMENT2 = ? and c.SEGMENT3 = ? and c.SEGMENT4 = ? and c.SEGMENT5 = ? and c.SEGMENT6 = ? and c.SEGMENT7 = ? 2019-02-08 22:40:40.524 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegments - ==&gt; Parameters: 050(String), 0(String), 71205(String), S101005(String), 50010(String), 1101(String), I101(String)2019-02-08 22:40:40.532 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegments - &lt;== Total: 12019-02-08 22:40:43.259 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentList - ==&gt; Preparing: select c.* from XXGL_CODE_COMBINATIONS c WHERE c.ENABLED_FLAG = 'Y' and c.SEGMENT1 = ? and c.SEGMENT2 = ? and c.SEGMENT3 = ? and c.SEGMENT4 = ? and c.SEGMENT5 = ? and c.SEGMENT6 = ? and c.SEGMENT7 = ? 2019-02-08 22:40:43.259 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentList - ==&gt; Parameters: 050(String), 0(String), 71205(String), S101005(String), 50010(String), 1101(String), I101(String)2019-02-08 22:40:43.263 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentList - &lt;== Total: 12019-02-08 22:40:44.284 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentMap - ==&gt; Preparing: select c.* from XXGL_CODE_COMBINATIONS c WHERE c.ENABLED_FLAG = ? and c.SEGMENT1 = ? and c.SEGMENT2 = ? and c.SEGMENT3 = ? and c.SEGMENT4 = ? and c.SEGMENT5 = ? and c.SEGMENT6 = ? and c.SEGMENT7 = ? /* 2 */ and c.SEGMENT1 = ? /* 2 */ and c.SEGMENT2 = ? /* 2 */ and c.SEGMENT3 = ? /* 2 */ and c.SEGMENT4 = ? /* 2 */ and c.SEGMENT5 = ? /* 2 */ and c.SEGMENT6 = ? /* 2 */ and c.SEGMENT7 = ? 2019-02-08 22:40:44.284 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentMap - ==&gt; Parameters: Y(String), 050(String), 0(String), 71205(String), S101005(String), 50010(String), 1101(String), I101(String), 050(String), 0(String), 71205(String), S101005(String), 50010(String), 1101(String), I101(String)2019-02-08 22:40:44.289 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentMap - &lt;== Total: 1 json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374[&#123;"combinationId": 1000,"codeCombinationId": 300000003238305,"accountType": "E","enabledFlag": "Y","segment1": "050","segment2": "0","segment3": "71205","segment4": "S101005","segment5": "50010","segment6": "1101","segment7": "I101","segment8": "0","segment9": "0","segment10": "0","segment11": "0","segment12": "0","segment13": null,"segment14": null,"segment15": null,"segment16": null,"segment17": null,"segment18": null&#125;,&#123;"combinationId": 1000,"codeCombinationId": 300000003238305,"accountType": "E","enabledFlag": "Y","segment1": "050","segment2": "0","segment3": "71205","segment4": "S101005","segment5": "50010","segment6": "1101","segment7": "I101","segment8": "0","segment9": "0","segment10": "0","segment11": "0","segment12": "0","segment13": null,"segment14": null,"segment15": null,"segment16": null,"segment17": null,"segment18": null&#125;,&#123;"combinationId": 1000,"codeCombinationId": 300000003238305,"accountType": "E","enabledFlag": "Y","segment1": "050","segment2": "0","segment3": "71205","segment4": "S101005","segment5": "50010","segment6": "1101","segment7": "I101","segment8": "0","segment9": "0","segment10": "0","segment11": "0","segment12": "0","segment13": null,"segment14": null,"segment15": null,"segment16": null,"segment17": null,"segment18": null&#125;] 感谢https://blog.csdn.net/s592652578/article/details/52871884]]></content>
      <categories>
        <category>Java</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[航天信息金税盘接口 js 调用]]></title>
    <url>%2F2018%2F12%2F02%2Fessay%2Fgold-tax-js%2F</url>
    <content type="text"><![CDATA[背景 最近项目要求与单机版的金税盘接口进行对接，在这里简单记录一下自己的开发经验，希望可以帮助到有需要的人 PS：接口使用 js 对接，仅支持 ie 浏览器。 前置条件在进行开发时候需要有一些前置条件 ie 浏览器 开启 activeX 控件 设置 –&gt; Internet 选项 –&gt; 安全 –&gt; 自定义级别 把 activeX 相关设置勾上 可参考: 管理员身份运行调试 如果开票软件安装到本地 C盘 需要使用管理员打开 ie 浏览器，然后再进行调试 金税盘安装 要确保金税盘安装准确安装了TaxCardX.dll 通用 js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395/** 航信金税盘相关function */var goldTax = &#123; /** * 使用前先判断是否是ie浏览器 * @return true/false */ isIE: function () &#123; if(!!window.ActiveXObject || "ActiveXObject" in window) return true; else return false; &#125;, /** * 开启金税盘 * @param certPassword 单机版为证书口令 服务器版为地址 留空则读取开票BIN文件下cert.txt * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx', // 错误信息 * 'data': &#123;&#125; // 接口返回相关数据 * &#125; * &lt;/pre&gt; */ openCard: function (certPassword) &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '', 'data': &#123;&#125; &#125;; try &#123; goldTax.card = new ActiveXObject("TaxCardX.GoldTax"); // 单机版为证书口令 服务器版为地址 留空则读取开票BIN文件下cert.txt if(typeof certPassword != 'undefined') &#123; goldTax.card.CertPassword = certPassword; &#125; // 开启金税盘 goldTax.card.OpenCard(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // 1011 开启成功 if (result.code == 1011) &#123; result.success = true; result.data = &#123; RetCode: goldTax.card.RetCode, /* RetCode - 状态码， 1011 开启成功 */ RetMsg: goldTax.card.RetMsg, /* RetMsg 状态信息 */ InvLimit: goldTax.card.InvLimit, /* InvLimit – 开票限额, 金税卡发票开具价税合计限额 */ TaxCode: goldTax.card.TaxCode, /* TaxCode 本单位税号 */ TaxClock: goldTax.card.TaxClock, /* TaxClock – 金税卡时钟 */ MachineNo: goldTax.card.MachineNo, /* MachineNo – 开票机号码，主开票机为 0 */ IsInvEmpty: goldTax.card.IsInvEmpty, /* IsInvEmpty – 有票标志，0为金税卡中无可开发票，1为有票 */ IsRepReached: goldTax.card.IsRepReached, /* IsRepReached – 抄税标志，0为未到抄税期，1为已到抄税期 */ IsLockReached: goldTax.card.IsLockReached, /* IsLockReached – 锁死标志，0为未到锁死期，1为已到锁死期 */ &#125;; &#125; else &#123; result.success = false; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125;, /** * 关闭金税盘 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx' // 错误信息 * &#125; * &lt;/pre&gt; */ closeCard: function() &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '' &#125;; if (typeof goldTax.card != 'undefined') &#123; try &#123; goldTax.card.closeCard(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // RetCode 9000 调用成功，其他失败 if (result.code == 9000) &#123; result.success = true; &#125; else &#123; result.success = false; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125; &#125;, /** * 查询库存发票 * @param invKind 发票种类 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx', // 错误信息 * 'data': &#123;&#125; // 接口返回相关数据 * &#125; * &lt;/pre&gt; */ invoiceInventory: function(invKind) &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '', 'data': &#123;&#125; &#125;; try &#123; if (typeof goldTax.card != 'undefined') &#123; goldTax.card.InfoKind = invKind; goldTax.card.GetInfo(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // RetCode 3011 读取成功，其他失败 if (result.code == 3011) &#123; result.success = true; result.data = &#123; RetCode: goldTax.card.RetCode, /* RetCode - 状态码， 3011 读取成功，其他失败 */ RetMsg: goldTax.card.RetMsg, /* RetMsg 状态信息 */ InfoTypeCode: goldTax.card.InfoTypeCode, /* 要开具发票的十位代码。为空或全为0时，表示无可用发票 */ InfoNumber: goldTax.card.InfoNumber, /* 要开具发票的号码 */ InvStock: goldTax.card.InvStock, /* 剩余的可用发票份数 */ TaxClock: goldTax.card.TaxClock /* 金税盘时钟 */ &#125;; &#125; else &#123; result.success = false; &#125; &#125; else &#123; result.success = false; result.code = -1; result.msg = 'Please Open Card First'; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125;, /** * 发票校验 * @param o 传入发票信息 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx', // 错误信息 * 'data': &#123;&#125; // 接口返回相关数据 * &#125; * &lt;/pre&gt; */ invoiceVeriferify: function(o) &#123; return goldTax.inner.invoice(1, o); &#125;, /** * 发票开具 * @param o 传入发票信息 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx', // 错误信息 * 'data': &#123;&#125; // 接口返回相关数据 * &#125; * &lt;/pre&gt; */ invoicing: function(o) &#123; return goldTax.inner.invoice(0, o); &#125;, /** * 发票打印 * @param o 传入发票信息 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx' // 错误信息 * &#125; * &lt;/pre&gt; */ printInv: function(o) &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '' &#125;; try &#123; if (typeof goldTax.card != 'undefined') &#123; goldTax.card.InfoKind = o.InfoKind; /* 发票种类（0：专用发票 2：普通发票 11：货物运输业增值税专用发票 12：机动车销售统一发票） */ goldTax.card.InfoTypeCode = o.InfoTypeCode; /* 要打印发票的十位代码 */ goldTax.card.InfoNumber = o.InfoNumber; /* 要打印发票的号码 */ goldTax.card.GoodsListFlag = o.GoodsListFlag; /* 销货清单标志，0 – 打印发票，1 – 打印销货清单 */ goldTax.card.InfoShowPrtDlg = o.InfoShowPrtDlg; /* 打印时是否显示边距确认对话框，0 – 不出现，1 – 出现 */ // 调用接口 goldTax.card.PrintInv(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // RetCode 5011 打印成功，5001 – 未找到发票或清单，5012 – 未打印，5013 – 打印失败 if (result.code == 5011) &#123; result.success = true; &#125; else &#123; result.success = false; &#125; &#125; else &#123; result.success = false; result.code = -1; result.msg = 'Please Open Card First'; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125;, /** * 已开发票作废 * @param o 传入发票信息 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx' // 错误信息 * &#125; * &lt;/pre&gt; */ cancelInv: function(o) &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '' &#125;; try &#123; if (typeof goldTax.card != 'undefined') &#123; goldTax.card.InfoKind = o.InfoKind; /* 发票种类（0：专用发票 2：普通发票 11：货物运输业增值税专用发票 12：机动车销售统一发票） */ goldTax.card.InfoTypeCode = o.InfoTypeCode; /* 要作废发票的十位或十二位代码 */ goldTax.card.InfoNumber = o.InfoNumber; /* 要作废发票的号码 */ // 调用接口 goldTax.card.CancelInv(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // RetCode 6011 打印成功，6001 – 当月发票库未找到该发票，6002 – 该发票已经作废，6012 – 作废失败，6013 – 作废失败(异常) if (result.code == 6011) &#123; result.success = true; &#125; else &#123; result.success = false; &#125; &#125; else &#123; result.success = false; result.code = -1; result.msg = 'Please Open Card First'; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125;, // 内部方法 inner: &#123; /** * invoice 接口 * @param checkEWM 默认为0（0: 发票开具, 1: 发票校验, 2: 空白作废) * @param o 传入发票信息 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx', // 错误信息 * 'data': &#123;&#125; // 接口返回相关数据 * &#125; * &lt;/pre&gt; */ invoice: function(checkEWM, o) &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '', 'data': &#123;&#125; &#125;; try &#123; if (typeof goldTax.card != 'undefined') &#123; // CheckEWM值默认为0（为1时用于发票校验。 // 注意：一旦CheckEWM值置1用于发票校验之后， //如果要再进行发票开具必须手动将CheckEWM值置为0，否则Invoice()方法的功能将一直处于发票校验状态） goldTax.card.CheckEWM = checkEWM; goldTax.card.InvInfoInit(); /* 初始化发票抬头信息 */ goldTax.card.InfoKind = o.InfoKind; /* 增值税普通发票2 专票0 */ goldTax.card.InfoClientName = o.InfoClientName; /* 购方名称 */ goldTax.card.InfoClientTaxCode = o.InfoClientTaxCode; /* 购方税号 */ goldTax.card.InfoClientBankAccount = o.InfoClientBankAccount; /* 购方开户行及账号 */ goldTax.card.InfoClientAddressPhone = o.InfoClientAddressPhone; /* 购方地址电话 */ goldTax.card.InfoSellerBankAccount = o.InfoSellerBankAccount; /* 销方开户行及账号 */ goldTax.card.InfoSellerAddressPhone = o.InfoSellerAddressPhone; /* 销方地址电话 */ // 如果是多商品多税率 税率应该放到下面商品信息循环里 if (typeof o.InfoTaxRate != 'undefined' &amp;&amp; o.InfoTaxRate) &#123; goldTax.card.InfoTaxRate = o.InfoTaxRate; /* 税率,(已授权的税率， 17% 传17) */ &#125; goldTax.card.InfoNotes = o.InfoNotes; /* 备注 */ goldTax.card.InfoInvoicer = o.InfoInvoicer; /* 开票人 */ // 复核人，可为空 if (typeof o.InfoChecker != 'undefined' &amp;&amp; o.InfoChecker) &#123; goldTax.card.InfoChecker = o.InfoChecker; &#125; // 收款人，可为空 if (typeof o.InfoCashier != 'undefined' &amp;&amp; o.InfoCashier) &#123; goldTax.card.InfoCashier = o.InfoCashier; &#125; // 如不为空，则开具销货清单，此为发票上商品名称栏的清单信息，应为“(详见销货清单)”字样 if (typeof o.InfoListName != 'undefined' &amp;&amp; o.InfoListName) &#123; goldTax.card.InfoListName = o.InfoListName; &#125; // 清空商品明细列表 goldTax.card.ClearInvList(); // 遍历行 $.each(o.InvList, function(i, v) &#123; goldTax.card.InvListInit(); /* 初始化发票明细信息各项属性 */ goldTax.card.ListGoodsName = v.ListGoodsName; /* 商品或劳务名称 */ goldTax.card.ListTaxItem = v.ListTaxItem; /* 税目，4位数字，商品所属类别 */ goldTax.card.ListStandard = v.ListStandard; /* 规格型号 */ // 计量单位，如计量单位为空，则忽略数量和单价 if (typeof v.ListUnit != 'undefined' &amp;&amp; v.ListUnit) &#123; goldTax.card.ListUnit = v.ListUnit; &#125; // 建议传入数量和含税单价或含税金额 由接口计算带小数的税额 规避误差 goldTax.card.ListNumber = v.ListNumber; // 数量 goldTax.card.ListPrice = v.ListPrice; // 单价 // 金额，可以不传(为0)，由接口软件计算，如传入则应符合计算关系 if (typeof v.ListAmount != 'undefined' &amp;&amp; v.ListAmount ) &#123; goldTax.card.ListAmount = v.ListAmount; &#125; goldTax.card.ListPriceKind = v.ListPriceKind; /* 含税价标志，单价和金额的种类， 0为不含税价，1为含税价 */ // 税额可以不传(为0)，由接口软件计算，如传入则应符合计算关系 if (typeof v.ListTaxAmount != 'undefined' &amp;&amp; v.ListTaxAmount) &#123; goldTax.card.ListTaxAmount = v.ListTaxAmount; &#125; // 添加一行 goldTax.card.AddInvList(); &#125;); // 调用接口 goldTax.card.Invoice(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // RetCode 4011 开票成功，其他失败 if (result.code == 4011) &#123; result.success = true; result.data = &#123; RetCode: goldTax.card.RetCode, /* RetCode - 状态码， 3011 读取成功，其他失败 */ RetMsg: goldTax.card.RetMsg, /* RetMsg 状态信息 */ InfoAmount: goldTax.card.InfoAmount , /* 合计不含税金额 */ InfoTaxAmount: goldTax.card.InfoTaxAmount, /* 合计税额 */ InfoInvDate: goldTax.card.InfoInvDate, /* 开票日期 */ InfMonth: goldTax.card.InfMonth, /* 所属月份 */ InfoTypeCode: goldTax.card.InfoTypeCode, /* 发票十位代码 */ InfoNumber: goldTax.card.InfoNumber, /* 发票号码 */ GoodsListFlag: goldTax.card.GoodsListFlag /* 销货清单标志，0 – 无销货清单，1 – 有销货清单 */ &#125;; &#125; else &#123; result.success = false; &#125; &#125; else &#123; result.success = false; result.code = -1; result.msg = 'Please Open Card First'; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125; &#125;&#125;; 相关资料CSDN 需要积分下载 金税 防伪税控 组件接口 开发文档 代码案例 没有积分的 戳这里]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ActiveX</tag>
        <tag>金税</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
