<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何使用 webservice 备份报表 catalog 对象]]></title>
    <url>%2F2019%2F08%2F24%2Foracle-cloud%2Fwebservice%2Fbackup-catalog-object%2F</url>
    <content type="text"><![CDATA[手动备份如果不是经常需要进行备份可以通过手动进行备份，没必要通过 webservice 备份，可以使用以下两种方式手动操作 BIP: Downloading and Uploading Catalog Objects OBIEE: Archiving Objects ps: 进入BI Publisher https://xxx.com/xmlpserver webservice 备份其实只是用 webservice 的方式进行 BIP 备份的两步操作 主要使用 webservice: https://xxx.com/xmlpserver/services/v2/CatalogService?wsdl 中的 downloadObject 和 uploadObject 或者 updateObject 通常情况下，我们只需要调用 downloadObject, 获取 catalog objects 然后手动通过 BIP 界面上传还原即可完成整个备份还原流程了。简单介绍一下流程 请求报文 123456789&lt;Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;Body&gt; &lt;downloadObject xmlns="http://xmlns.oracle.com/oxp/service/v2"&gt; &lt;reportAbsolutePath&gt;/Custom/Financials/General Ledger&lt;/reportAbsolutePath&gt; &lt;userID&gt;****&lt;/userID&gt; &lt;password&gt;***&lt;/password&gt; &lt;/downloadObject&gt; &lt;/Body&gt;&lt;/Envelope&gt; reportAbsolutePath: 报表路径，假设我们要备份共享目录客制化的 /Custom/Financials/General Ledger 目录，填写 /Custom/Financials/General Ledger userID：用户名 password: 密码 响应报文 通过获取的 base64binary Code 解密生成文件就完成了文件备份的步骤了 测试的话可以通过 https://www.hitoy.org/tool/file_base64.php 在线对 base64binary Code 转换成文件，这里下载的是文件夹因此后缀名写 xdrz, 后缀名对应请往下看 文件后缀名确定catalog 对象文件后缀名的对应如下，在转文件时需要使用正确的后缀名，不然 BIP 上传还原报错 Catalog Object Extension Assigned to Downloaded Files Data Model .xdmz Folder .xdrz Report .xdoz Style Template .xssz Subtemplate .xsbz BIP 上传 catalog 对象进行还原输入网址 https://xxx.com/xmlpserver 进入 BIP 界面 进入 catalog 管理界面，下图两个框框位置都可以进入 进入要还原到的目录下进行以下操作 还原成功 测试结果分析后期测试发现，下载的文件夹，如果里面的内容过多（猜测是文件夹过多）会导致upload的时候失败，原因未明，另外发现通过下载上传的方式无法保留原文件的权限等设置。因此，感觉如非必要还是通过 OBIEE 方式进行备份吧（也就是归档与反归档）]]></content>
      <categories>
        <category>Oracle Cloud</category>
        <category>webservice</category>
      </categories>
      <tags>
        <tag>Oracle Cloud</tag>
        <tag>catalog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle cloud 用户角色权限表关系]]></title>
    <url>%2F2019%2F08%2F23%2Foracle-cloud%2Fuser-role-privilege%2F</url>
    <content type="text"><![CDATA[Cloud 查看用户角色权限 表关系主要涉及表： 前缀ASE开头的 ASE_USER_VL 用户表 ASE_USER_ROLE_MBR 用户角色分配表 ASE_ROLE_VL 角色表 ASE_PRIVILEGE_VL 权限表 ASE_PRIV_ROLE_MBR 权限角色表 ASE_ROLE_ROLE_MBR 角色父子关系表 sql 查询角色父子关系12345678910111213141516SELECT t.parent_role_id, pr.code AS parent_role_code, pr.role_name AS parent_role_name, t.leaf, t.ase_role_id, r.code AS role_code, r.role_name FROM (SELECT parent_role_id, connect_by_isleaf leaf, connect_by_root(child_role_id) ase_role_id FROM ase_role_role_mbr CONNECT BY PRIOR ase_role_role_mbr.parent_role_id = ase_role_role_mbr.child_role_id) t, ase_role_vl pr, ase_role_vl r WHERE t.parent_role_id = pr.role_id(+) AND t.ase_role_id = r.role_id 用户角色查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102WITH-- 角色父子关系role_role_mbr_ AS (SELECT t.parent_role_id, pr.code AS parent_role_code, pr.role_name AS parent_role_name, t.leaf, t.ase_role_id, r.code AS role_code, r.role_name FROM (SELECT parent_role_id, connect_by_isleaf leaf, connect_by_root(child_role_id) ase_role_id FROM ase_role_role_mbr CONNECT BY PRIOR ase_role_role_mbr.parent_role_id = ase_role_role_mbr.child_role_id) t, ase_role_vl pr, ase_role_vl r WHERE t.parent_role_id = pr.role_id(+) AND t.ase_role_id = r.role_id),-- 用户角色user_role_ AS (SELECT u.user_login, u.user_display_name, -- 与当前日期比较判断是否有效 decode((SELECT 1 FROM dual WHERE (u.effective_start_date &lt;= SYSDATE OR u.effective_start_date IS NULL) AND (u.effective_end_date &gt;= SYSDATE OR u.effective_end_date IS NULL)), 1, 'Active', 'Inactive') AS is_user_active, u.creation_date AS user_creation_date, u.last_update_date AS user_last_update_date, r.role_id, r.code AS role_code, r.role_name, -- 与当前日期比较判断是否有效 decode((SELECT 1 FROM dual WHERE (r.effective_start_date &lt;= SYSDATE OR r.effective_start_date IS NULL) AND (r.effective_end_date &gt;= SYSDATE OR r.effective_end_date IS NULL)), 1, 'Active', 'Inactive') AS is_role_active, r.creation_date AS role_creation_date, r.last_update_date AS role_last_update_date, -- 与当前日期比较判断是否有效 decode((SELECT 1 FROM dual WHERE (ur.effective_start_date &lt;= SYSDATE OR ur.effective_start_date IS NULL) AND (ur.effective_end_date &gt;= SYSDATE OR ur.effective_end_date IS NULL)), 1, 'Active', 'Inactive') AS is_user_role_active, ur.creation_date AS user_role_creation_date, ur.last_update_date AS user_role_last_update_date FROM fusion.ase_user_vl u, fusion.ase_user_role_mbr ur, fusion.ase_role_vl r WHERE u.user_id = ur.user_id AND r.role_id = ur.role_id)-- 主查询SELECT t.user_login, t.user_display_name, t.is_user_active, t.user_creation_date, t.user_last_update_date, t.role_code, t.role_name, rr.parent_role_code, rr.parent_role_name, t.is_role_active, t.role_creation_date, t.role_last_update_date, t.is_user_role_active, t.user_role_creation_date, t.user_role_last_update_date FROM user_role_ t, role_role_mbr_ rr WHERE t.role_id = rr.ase_role_id(+) /* 参数 */ -- 用户登陆名 AND (t.user_login = :p_user OR :p_user IS NULL) -- 角色编码，包含父角色 AND (:p_role_code IS NULL OR t.role_code = :p_role_code OR rr.parent_role_code = :p_role_code) -- 用户是否有效 AND (t.is_user_active = :p_user_active OR :p_user_active IS NULL) -- 角色是否有效 AND (t.is_role_active = :p_role_active OR :p_role_active IS NULL) -- 用户角色分配是否有效 AND (t.is_user_role_active = :p_user_role_active OR :p_user_role_active IS NULL) -- 用户创建时间 AND (t.user_creation_date &gt;= :p_user_creation_date_from OR :p_user_creation_date_from IS NULL) AND (t.user_creation_date &lt;= :p_user_creation_date_to OR :p_user_creation_date_to IS NULL) -- 角色创建时间 AND (t.role_creation_date &gt;= :p_role_creation_date_from OR :p_role_creation_date_from IS NULL) AND (t.role_creation_date &lt;= :p_role_creation_date_to OR :p_role_creation_date_to IS NULL) -- 用户角色创建时间 AND (t.user_role_creation_date &gt;= :p_ur_creation_date_from OR :p_ur_creation_date_from IS NULL) AND (t.user_role_creation_date &lt;= :p_ur_creation_date_to OR :p_ur_creation_date_to IS NULL) 参考https://community.oracle.com/thread/3924763?parent=MOSC_EXTERNAL&amp;sourceId=MOSC&amp;id=3924763]]></content>
      <categories>
        <category>Oracle Cloud</category>
      </categories>
      <tags>
        <tag>Oracle Cloud</tag>
        <tag>Role-Privileges</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识 OOM]]></title>
    <url>%2F2019%2F06%2F20%2FJava%2Fjvm%2Foom-1%2F</url>
    <content type="text"><![CDATA[什么是 OOMOOM，Out of Memory，也就是超出了预设内存。 java.lang.OutOfMemoryError，官方说明： Thrown when the Java Virtual Machine cannot allocate an object because it is out of memory, and no more memory could be made available by the garbage collector. 意思就是说，当 JVM 没有足够的内存来为对象分配空间，并且垃圾回收器也已经没有空间可回收时，就会抛出这个error（注：非exception，因为这个问题已经严重到不足以被应用处理）。 为什么会 OOM主要原因有两点 分配内存不足，可用通过调整启动 VM 参数控制。 程序逻辑问题，占用过多内存并且使用完没有及时释放，造成内存泄露或者内存溢出。 其中： 内存泄漏：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。（往往是编码不当导致） 内存溢出：申请的内存超出了JVM能提供的内存大小，此时称之为溢出。 JVM 内存模型上面频繁提到的内存指的就是 JVM 内存模型。 JVM 在运行会管理以下的内存区域： 程序计数器：当前线程执行的字节码的行号指示器，线程私有，记录每个线程当前执行字节码的位置，因为会有多个线程来并发执行各种不同的代码，所有每个线程会有自己的一个程序计数器，专门记录这个线程目前执行到哪一条字节码指令，也就是线程私有； java 虚拟机栈：保存方法内局部变量数据的区域，线程私有。线程执行了一个方法，那么就会为这个方法调用创建对应的一个栈帧。栈帧里有这个方法的局部变量表 、操作数栈、动态链接、方法出口等东西，调用执行任何方法的时候，都会给方法创建栈帧，然后入栈，调用完再出栈； 本地方法栈：类似“java 虚拟机栈”，但是为 native 方法的运行提供内存环境，调用本地操作系统里面的一些方法，可能是调用 c 语言写的底层类库提供的内存环境； java 堆内存：对象内存分配的地方，内存垃圾回收的主要区域，所有线程共享。对象按不同的 “生存” 情况分为新生代，老年代等； 方法区/Metaspace：JDK 1.8 后叫做 Metaspace，JDK 8 开始把类的元数据放到本地堆内存(native heap)中，这一块区域就叫 Metaspace，详情见深入探究 JVM | 探秘 Metaspace； 堆外内存：并不是 JVM 运行时数据区的一部分，可直接访问的内存，比如 NIO 会用到这部分； OOM 类型 java.lang.OutOfMemoryError: Java heap space，比较常见，java 堆内存溢出。详情见OutOfMemoryError系列（1）: Java heap space java.lang.OutOfMemoryError: GC overhead limit exceeded，程序基本上耗尽了所有的可用内存, GC也清理不了。详情见OutOfMemoryError系列（2）: GC overhead limit exceeded java.lang.OutOfMemoryError: PermGen space，java 永久代溢出，也就是方法区溢出，jdk 7 之前。详情见OutOfMemoryError系列（3）: Permgen space java.lang.OutOfMemoryError: Metaspace，相当于 jdk 7以前的 java.lang.OutOfMemoryError: PermGen space。详情见OutOfMemoryError系列（4）: Metaspace java.lang.StackOverflowError，不会抛 OOM ERROR，但也是比较常见的 Java 内存溢出 查看应用进程id（pid）及启动 VM 参数jps -v 查找应用进程 id 1234jps -v29591 Jps -Dapplication.home=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.191.b12-1.el7_6.x86_64 -Xms8m9066 Bootstrap -Djava.util.logging.config.file=/xxx/tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Xms512m -Xmx2048m -Djdk.tls.ephemeralDHKeySize=2048 -Xms4096m -Xmx10240m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/xxx/dump -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=0027 -Dignore.endorsed.dirs= -Dcatalina.base=/xxx/tomcat -Dcatalina.home=/xxx/lib/tomcat -Djava.io.tmpdir=/xxx/tomcat/temp jinfo -flags &lt;pid&gt; 查看 VM 启动参数 12345678jinfo -flags 9066Attaching to process ID 9066, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.191-b12Non-default VM flags: -XX:CICompilerCount=3 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=null -XX:InitialHeapSize=4294967296 -XX:MaxHeapSize=10737418240 -XX:MaxNewSize=3578789888 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=1431306240 -XX:OldSize=2863661056 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGCCommand line: -Djava.util.logging.config.file=/xxx/tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Xms512m -Xmx2048m -Djdk.tls.ephemeralDHKeySize=2048 -Xms4096m -Xmx10240m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/xxx/dump -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=0027 -Dignore.endorsed.dirs= -Dcatalina.base=/xxx/tomcat -Dcatalina.home=/xxx/lib/tomcat -Djava.io.tmpdir=/xxx/tomcat/temp jmap -heap &lt;pid&gt; 查看 VM 启动参数，以及堆内存情况 123456789101112131415161718192021222324252627282930313233343536373839jmap -heap 9066Attaching to process ID 9066, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.191-b12using thread-local object allocation.Parallel GC with 4 thread(s)Heap Configuration: MinHeapFreeRatio = 0 MaxHeapFreeRatio = 100 MaxHeapSize = 10737418240 (10240.0MB) NewSize = 1431306240 (1365.0MB) MaxNewSize = 3578789888 (3413.0MB) OldSize = 2863661056 (2731.0MB) NewRatio = 2 SurvivorRatio = 8 MetaspaceSize = 21807104 (20.796875MB) CompressedClassSpaceSize = 1073741824 (1024.0MB) MaxMetaspaceSize = 17592186044415 MB G1HeapRegionSize = 0 (0.0MB)Heap Usage:Exception in thread "main" java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at sun.tools.jmap.JMap.runTool(JMap.java:201) at sun.tools.jmap.JMap.main(JMap.java:130)Caused by: java.lang.RuntimeException: unknown CollectedHeap type : class sun.jvm.hotspot.gc_interface.CollectedHeap at sun.jvm.hotspot.tools.HeapSummary.run(HeapSummary.java:157) at sun.jvm.hotspot.tools.Tool.startInternal(Tool.java:260) at sun.jvm.hotspot.tools.Tool.start(Tool.java:223) at sun.jvm.hotspot.tools.Tool.execute(Tool.java:118) at sun.jvm.hotspot.tools.HeapSummary.main(HeapSummary.java:50) ... 6 more 上面报错解决 Exception when taking a heapdump using JMAP 解决再运行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748jmap -heap 9066Attaching to process ID 9066, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.191-b12using thread-local object allocation.Parallel GC with 4 thread(s)Heap Configuration: MinHeapFreeRatio = 0 MaxHeapFreeRatio = 100 MaxHeapSize = 10737418240 (10240.0MB) NewSize = 1431306240 (1365.0MB) MaxNewSize = 3578789888 (3413.0MB) OldSize = 2863661056 (2731.0MB) NewRatio = 2 SurvivorRatio = 8 MetaspaceSize = 21807104 (20.796875MB) CompressedClassSpaceSize = 1073741824 (1024.0MB) MaxMetaspaceSize = 17592186044415 MB G1HeapRegionSize = 0 (0.0MB)Heap Usage:PS Young GenerationEden Space: capacity = 1209532416 (1153.5MB) used = 279076032 (266.14764404296875MB) free = 930456384 (887.3523559570312MB) 23.073051065710338% usedFrom Space: capacity = 112721920 (107.5MB) used = 9442424 (9.004997253417969MB) free = 103279496 (98.49500274658203MB) 8.376741631086482% usedTo Space: capacity = 109051904 (104.0MB) used = 0 (0.0MB) free = 109051904 (104.0MB) 0.0% usedPS Old Generation capacity = 2976907264 (2839.0MB) used = 609708576 (581.4634094238281MB) free = 2367198688 (2257.536590576172MB) 20.481275428806907% used67050 interned Strings occupying 6996392 bytes. 获取到的 VM 参数，可关注如下几项参数的情况 12345678-XX:+HeapDumpOnOutOfMemoryError # 是否开启 OOM 时输出 dump 文件，+ 表示开启-XX:HeapDumpPath=/data/logs # 若配置该项，dump 文件输出到该路径下-XX:+PrintGCDetails # 是否打印 GC 详细信息-XX:+PrintGCTimeStamps # 是否打印 GC 时间戳(基准形式)-XX:+PrintGCDateStamps # 是否打印 GC 时间戳(日期形式)-XX:+PrintTenuringDistribution # 在每次新生代 GC 时，输出幸存区中对象的年龄分布-Xloggc:/data/logs # 若配置该项，GC 日志输出到该路径下 如果应用没有启用相应的参数输出日志，可以进行以下操作查看相关日志 12345# 1.查看应用 GC 次数及平均每次 GC 时间jstat -gc &lt;pid&gt; 5000 # 每 5 秒显示一次 pid 的进程生成 GC 情况# 2.查看 JVM 堆内存不同代的具体使用情况jmap -heap &lt;pid&gt; # 参照上面使用 参考Java OOM 分析 OutOfMemoryError系列 深入探究 JVM | 探秘 Metaspace]]></content>
      <categories>
        <category>Java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译文] Spring Security – security none, filters none, access permitAll]]></title>
    <url>%2F2019%2F03%2F28%2FJava%2Fspring%2Fsecurity-none-filters-none-access-permitAll%2F</url>
    <content type="text"><![CDATA[版权说明，文章翻译至 Spring Security – security none, filters none, access permitAll 概述Spring Security 提供了几种将请求模式配置为不安全或者允许所有访问的机制。根据这些机制的不同，这可能意味着根本不在这个路径上运行安全过滤器链，或者运行了安全过滤器链但允许访问。 access=”permitAll”给 &lt;intercept-url> 标签设置 access=”permitAll” 元素，将会给指定路径允许所有请求授权: 1&lt;intercept-url pattern="/login*" access="permitAll" /&gt; 或者通过 java 配置: 1http.authorizeRequests().antMatchers("/login*").permitAll() 这是在不禁用安全过滤器的情况下实现的，这些过滤器仍在运行，因此任何与 Spring Security 相关的功能仍然可以使用。 filters=”none”这是在 Spring 3.1 前的功能，已在 Spring 3.1 中弃用和被替代了。 这个 filter 属性完全禁用指定的请求路径上的 Spring Security 过滤器链: 1&lt;intercept-url pattern="/login*" filters="none" /&gt; 当处理请求需要 Spring Security 的某些功能时，这可能会有问题。 由于在 Spring 3.0+ 版本这是一个被弃用的功能，在 Spring 3.1 中使用它将导致启动时出现运行时异常: 1234567SEVERE: Context initialization failedorg.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: The use of "filters='none'" is no longer supported. Please define a separate &lt;http&gt; element for the pattern you want to exclude and use the attribute "security='none'".Offending resource: class path resource [webSecurityConfig.xml] at o.s.b.f.p.FailFastProblemReporter.error(FailFastProblemReporter.java:68) security=”none”正如我们在上面的错误消息中看到的那样，Spring 3.1 用一个新的表达式替换 filters =“none” - security =“none”。 范围也发生了变化 —— 这不再在 &lt;intercept-url> 元素级别指定。相反，Spring 3.1 允许定义多个 &lt;http> 元素，每个元素都有自己的安全过滤链配置。因此，新的安全属性现在属于 &lt;http> 元素级别。 在实际使用中，它长这样: 1&lt;http pattern="/resources/**" security="none"/&gt; 或者通过 java 配置: 1web.ignoring().antMatchers("/resources/**"); 而不是旧的: 1&lt;intercept-url pattern="/resources/**" filters="none"/&gt; 与 filters =“none” 类似，这也将完全禁用该请求路径的安全过滤器链 - 因此，当在应用程序中处理请求时，Spring Security 功能将不可用。 对于上面的示例而言，这不是问题，其主要涉及提供静态资源 - 在实际中不需要做特殊处理。但是，如果以某种方式以编程方式处理请求 - 那么安全功能（例如，requires-channel，访问当前用户或调用安全方法）将不可用。 出于同样的原因，在已经配置了 security=”none” 的 &lt;http> 元素上指定附加属性是没有意义的，因为该请求路径是不安全的，这些属性将被忽略。 或者，access=’IS_AUTHENTICATED_ANONYMOUSLY’ 可用于允许匿名访问。 Caveats for security=”none”当使用多个 &lt;http> 元素时，有些配置了 security =“none”，请记住，定义这些元素的顺序很重要。我们应该首先使用特定的 &lt;http> 路径，最后再使用通用模式。 另请注意，如果 &lt;http> 元素未指定模式，则默认情况下，映射到通用匹配模式 - “/** ” - 因此，此元素必须是最后一个。如果元素的顺序不正确，则安全过滤器链的创建将失败： 12345Caused by: java.lang.IllegalArgumentException: A universal match pattern ('/**') is defined before other patterns in the filter chain, causing them to be ignored. Please check the ordering in your &lt;security:http&gt; namespace or FilterChainProxy bean configuration at o.s.s.c.h.DefaultFilterChainValidator.checkPathOrder(DefaultFilterChainValidator.java:49) at o.s.s.c.h.DefaultFilterChainValidator.validate(DefaultFilterChainValidator.java:39) 结论本文讨论了允许使用 Spring Security 访问路径的选项 - 重点关注 filters =“none”，security =“none” 和 access =“permitAll” 之间的差异。 像往常一样，这些例子可以在 GitHub 上找到。 参考资料 Spring Security – security none, filters none, access permitAll]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 代理中转下载 url 文件]]></title>
    <url>%2F2019%2F03%2F21%2FJava%2Fjava-proxy-url-file%2F</url>
    <content type="text"><![CDATA[场景描述我们有一个外网访问的 java web 系统 A，这个系统会去请求一个内网系统 B 获取文件接口，这个接口会返回一个内网的下载地址给我们。假如我们只是把地址提供出去，这个时候外网是无法下载到文件的，所以我们需要在 A 系统对 B 系统返回的文件下载地址进行中转，从而暴露出基于 A 系统的外网下载地址。 代码开发12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * url 文件代理中转 * @param response * @param address * @param contentType * @param fileName * @throws IOException */ public static void proxyUrlFile(HttpServletResponse response, String address, String contentType, String fileName) throws IOException &#123; InputStream inputStream = null; ServletOutputStream outputStream = null; HttpURLConnection httpURLConnection = null; try &#123; URL url = new URL(address); httpURLConnection = (HttpURLConnection) url.openConnection(); httpURLConnection.connect(); inputStream = httpURLConnection.getInputStream(); outputStream = response.getOutputStream(); if (contentType != null) &#123; response.setContentType(contentType); &#125; else &#123; // 设置文件ContentType类型，这样设置，会自动判断下载文件类型 response.setContentType("multipart/form-data"); &#125; if (fileName != null) &#123; response.setHeader("Content-disposition", "attachment; filename=\"" + new String(fileName.getBytes("utf-8"), "ISO8859-1")+"\""); &#125; // 创建一个Buffer字符串 byte[] buffer = new byte[1024]; // 每次读取的字符串长度，如果为-1，代表全部读取完毕 int len = 0; // 使用一个输入流从buffer里把数据读取出来 while((len = inputStream.read(buffer)) != -1 )&#123; // 用输出流往buffer里写入数据，中间参数代表从哪个位置开始读，len代表读取的长度 outputStream.write(buffer, 0, len); &#125; &#125; catch (Exception e) &#123; log.error("Proxy URL File error, e = &#123;&#125;", e); throw e; &#125; finally &#123; if (inputStream != null) &#123; inputStream.close(); &#125; if (outputStream != null) &#123; outputStream.flush(); outputStream.close(); &#125; if (httpURLConnection != null) &#123; httpURLConnection.disconnect(); &#125; &#125; &#125; 测试123456789101112131415@Controllerpublic class TestController &#123; /** * url 文件代理中转 * @param response * @param fileName * @param url * @throws IOException */ @RequestMapping("/fnd/proxy/url/file") public void proxyFile(HttpServletResponse response, @RequestParam("fileName") String fileName, @RequestParam("url") String url) throws IOException &#123; FileOperateUtil.proxyUrlFile(response, url, null, fileName); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADFS 安装及配置]]></title>
    <url>%2F2019%2F03%2F11%2Fsso%2Fadfs%2Fadfs-install%2F</url>
    <content type="text"><![CDATA[安装前准备在安装 ADFS 之前，我们需要准备号 DC，参考 ADDS 活动目录安装详解 安装配置证书服务在 DC 上安装 CA 打开服务器管理器，点击 “添加角色和功能” 保持默认，并连续点击三次“下一步” 勾选 “Active Directory 证书服务”，然后选择添加所需的功能，最后点“下一步”继续 功能选择页面保持默认，连续点击2次“下一步” 勾选 CA 相关服务, 一直点下一步，最后点击安装 安装完成 配置证书服务 CA 安装完成后，如图点击提示图标后，选择“配置目标服务器上的 Active Directory 证书服务” 根据向导进行配置 勾选所需要配置的服务 选择企业根 创建新的私钥 指定 CA 名称 指定有效期 指定数据库位置 确认配置信息 配置完成 验证 CA 以上环境准备好后就可以配置 ADFS 服务器了。在配置前我们需要给计算机或者指定的用户或者计算机授权证书颁发。 安装ADFS服务在安装 ADFS 之前，我们需要创建和配置证书 创建证书账户准备好后，然后申请证书，其实有很常见的两种方法，第一种就是通过iis进行证书申请，第二种通过 mmc 控制台进行申请，这里使用IIS的申请方法。 打开IIS管理器，选择【服务器证书】创建证书申请 保存到桌面上：cert.txt 配置证书 服务器浏览器，输入 http://127.0.0.1/certsrv/ 如下： 选择申请证书——&gt;高级证书申请 选择： 使用 base64 编码的 CMC 或 PKCS #10 文件提交 一个证书申请，或使用 base64 编码的 PKCS #7 文件续订证书申请 打开cert.txt ，粘贴进去，证书模板选择 web服务器，提交 下载证书，保存到本地： 回到iis管理器，选择完成证书申请 将 default web site 的 https 绑定证书改为刚才完成的证书 选择 default web site , 右键 编辑绑定，选择 https（没有则添加） ， 点击编辑，选择 ssl 证书:（ 这个证书在安装adfs时使用该证书） 开始安装 打开服务器管理器，点击 “添加角色和功能” 保持默认，并连续点击三次“下一步” 勾选 “Active Directory Federation Services” 安装服务角色 功能选择页面保持默认，连续点击2次“下一步” 安装 安装完成 ADFS 安装完成后，如图点击提示图标后，选择“在此服务器上配置联合身份验证服务” 功能选择页面保持默认，连续点击2次“下一步” 选择证书(不是前面创建的证书)，填写显示的名称 选择 adfs 服务帐号 指定配置数据库 下一步 配置 配置完成 至此 ADFS 安装配置完成 参考Windows Server 2016 安装及配置 ADFS 4.0 Server2012 下 部署adfs IFD]]></content>
      <categories>
        <category>SSO</category>
        <category>ADFS</category>
      </categories>
      <tags>
        <tag>SSO</tag>
        <tag>ADFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADDS 活动目录安装详解]]></title>
    <url>%2F2019%2F03%2F09%2Fsso%2Fadfs%2Fadds-install%2F</url>
    <content type="text"><![CDATA[安装前准备确保域控制器 (DC) 的计算机名符合企业命名规范，因为 AD 安装完成后再更改 DC 计算机相对复杂而且存在风险。DC 需要使用固定的静态IP地址，并且把DNS设置指向本机IP。 这台电脑 (右键) –&gt; 属性，更改设置： 网络 (右键) –&gt; 属性 –&gt; 以太网 –&gt; 属性 –&gt; Internet 协议版本 4（TCP/IPV4） –&gt; 属性 开始安装 打开服务器管理器，点击 “添加角色和功能” 保持默认，并连续点击三次“下一步”。 勾选 “ActiveDirectory域服务”，然后选择添加所需的功能，最后点“下一步”继续。 功能选择页面保持默认，连续点击2次“下一步”。 勾选自动重启服务器，点击“安装”。 完成ADDS安装后，如图点击提示图标后，选择“将此服务器提升为域控制器”。 由于这是第一台域控制器(DC)，也叫林根域。选择“添加新林”，然后输入根域名。 选择林和域功能级别，勾选DNS(AD需要高度集成DNS)，并输入目录还原模式密码。 由于现在还没有DNS服务器，所以会提示无法创建委派。直接“下一步”。 NetBIOS名以及ADDS数据库、日志、Sysvol保存位置，如果企业没有特殊要求，一般保持默认即可。 检查配置无误后点击“下一步”，然后点击“安装”，等待安装完成后重启即可。 至此完成 ActiveDirectory 的全部安装。已经可以对外提供服务了。 参考Active Directory管理之一:活动目录安装详解]]></content>
      <categories>
        <category>SSO</category>
        <category>ADFS</category>
      </categories>
      <tags>
        <tag>SSO</tag>
        <tag>ADFS</tag>
        <tag>ADDS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转载] 获取被代理类的真实类]]></title>
    <url>%2F2019%2F03%2F07%2FJava%2Fspring%2Ftarget-class%2F</url>
    <content type="text"><![CDATA[版权说明，文章转载自 Spring 笔记-获取被代理的真实类 对一个 Autowired 进来的类调用 getClass，发现得到的类是: com.xxx.search.provider.service.SearchServiceImpl$$EnhancerBySpringCGLIB$$129db519，一看就不是正经类。从名字中可以看出，这个是被代理后的类，可能因为这个类被AOP了吧。但是我在反射操作是需要原始的类的信息，要如何得到呢？ org.springframework.aop 下有一个很重要的接口: TargetClassAware, 这个接口表示目前这个类是被代理的。所以我们可以通过判断一个实例是否是 TargetClassAware 的实例来判断他是否是一个代理类。而且 TargetClassAware 接口提供了 getTargetClass 方法来获取真实类。可以这么用： 123if (aInstance instanceof TargetClassAware) &#123; aInstance.getTargetClass();&#125; 不过更推荐的做法是使用 org.springframework.aop.support.AopUtils 提供的 getTargetClass 方法来获取真实类。可以看看其源码： 12345678910111213public static Class&lt;?&gt; getTargetClass(Object candidate) &#123; Assert.notNull(candidate, "Candidate object must not be null"); Class result = null; if(candidate instanceof TargetClassAware) &#123; result = ((TargetClassAware)candidate).getTargetClass(); &#125; if(result == null) &#123; result = isCglibProxy(candidate)?candidate.getClass().getSuperclass():candidate.getClass(); &#125; return result;&#125; 代码首先判断当前类是否是 TargetClassAware 的实现，如果是，调用 getTargetClass，方法还判断当前类是否是 CglibProxy，如果是基于 cglib 的代理类，因为是基于继承来实现代理，所以获取父类就是真实类了。 参考资料 java - Obtain real Class object for Spring bean - Stack Overflow AopUtils)]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle cloud 如何获取图片 url]]></title>
    <url>%2F2019%2F02%2F20%2Foracle-cloud%2Fhow-to-get-image-url%2F</url>
    <content type="text"><![CDATA[以获取物料图片 url 作为例子 123456789101112(SELECT (decode(datatype_code, 'FILE', (:p_host || '/cs/idcplg?IdcService=GET_FILE&amp;dID=') || dm_version_number, 'WEB_PAGE', url)) AS image FROM fnd_attached_documents d, fnd_documents_vl dv WHERE d.document_id = d.document_id AND d.entity_name = 'ITEM_ENTITY' AND d.pk1_value = to_char(esi.organization_id) AND d.pk2_value = to_char(esi.inventory_item_id) AND rownum = 1) AS item_photo 其中 p_host 为 cloud 的主域名 其他类型的图片 url 可以通过变换 d.entity_name = &#39;ITEM_ENTITY&#39; 进行查找]]></content>
      <categories>
        <category>Oracle Cloud</category>
      </categories>
      <tags>
        <tag>Oracle Cloud</tag>
        <tag>attachment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何获取 oracle cloud 的 PO 的 shipping method]]></title>
    <url>%2F2019%2F02%2F20%2Foracle-cloud%2Fpo%2Fhow-to-get-shipping-method%2F</url>
    <content type="text"><![CDATA[版本信息 Oracle Cloud Application 19B (11.13.19.04.0) example 获取 po 头上的 shipping method 12345678910111213SELECT po_bip_helper.get_shipping_method(carrierpartyname.party_name, modeoftransportlookuppeo.meaning, servicelevellookuppeo.meaning) AS shippingmethod FROM wsh_carriers carrier, hz_parties carrierpartyname, fnd_lookups modeoftransportlookuppeo, fnd_lookups servicelevellookuppeo, po_headers_all header WHERE (header.mode_of_transport = modeoftransportlookuppeo.lookup_code(+) AND modeoftransportlookuppeo.lookup_type(+) = 'WSH_MODE_OF_TRANSPORT') AND (header.service_level = servicelevellookuppeo.lookup_code(+) AND servicelevellookuppeo.lookup_type(+) = 'WSH_SERVICE_LEVELS') AND header.carrier_id = carrier.carrier_id(+) AND carrier.carrier_id = carrierpartyname.party_id(+) AND header.segment1 = '20000028' 获取 po 行上的 shipping method 1234567891011121314SELECT po_bip_helper.get_shipping_method(carrierpartyname.party_name, modeoftransportlookuppeo.meaning, servicelevellookuppeo.meaning) AS shippingmethod FROM wsh_carriers carrier, hz_parties carrierpartyname, fnd_lookups modeoftransportlookuppeo, fnd_lookups servicelevellookuppeo, po_line_locations_all plla WHERE (plla.mode_of_transport = modeoftransportlookuppeo.lookup_code(+) AND modeoftransportlookuppeo.lookup_type(+) = 'WSH_MODE_OF_TRANSPORT') AND (plla.service_level = servicelevellookuppeo.lookup_code(+) AND servicelevellookuppeo.lookup_type(+) = 'WSH_SERVICE_LEVELS') AND plla.carrier_id = carrier.carrier_id(+) AND carrier.carrier_id = carrierpartyname.party_id(+) AND plla.po_header_id = pla.po_header_id AND plla.po_line_id = pla.po_line_id]]></content>
      <categories>
        <category>Oracle Cloud</category>
        <category>PO</category>
      </categories>
      <tags>
        <tag>Oracle Cloud</tag>
        <tag>PO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何获取 oracle cloud 的 Match Approval Level]]></title>
    <url>%2F2019%2F02%2F20%2Foracle-cloud%2Fhow-to-get-match-approval-level%2F</url>
    <content type="text"><![CDATA[版本信息Oracle Cloud Application Revision 13.18.10 (11.13.18.10.0) Title Description Oracle Application Development Framework JDEVADF_11.1.1.9.2ADF-REL131810-PROD-BP_GENERIC_181116.1437.7206 Oracle Middleware Extensions for Applications ATGPF_PT.REL13.18.10_GENERIC_181113.1603.REL13BP16.7 Database Compatibility TRUE (REL13BP16.7) 提示 When Receipt Required Flag is N, then Match Approval level is 2 way. When Receipt Required Flag is Y and Inspection Required Flag is N, then Match Approval Level is 3 way. When Receipt Required Flag is Y and Inspection Required Flag is Y, then Match Approval Level is 4 way. 2-way 不需要检测收货 receipt_required_flag 为 N 3-way 需要在 match invoice 的时候验收货 所以 receipt_required_flag 为Y , inspection_required_flag 为 N 4-way 还要检测验货 所以 两个都为 Y SQL123456789decode(poz_supplier_sites_v.receipt_required_flag, 'Y', decode(poz_supplier_sites_v.inspection_required_flag, 'Y', '4-Way', 'N', '3-Way'), 'N', '2-Way') AS matching_level 参考http://j178.mtgbb.com/?p=713]]></content>
      <categories>
        <category>Oracle Cloud</category>
      </categories>
      <tags>
        <tag>Oracle Cloud</tag>
        <tag>Match Approval Level</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitlab 更新 fork 的代码]]></title>
    <url>%2F2019%2F02%2F18%2Fgit%2Fgitlab-update-fork%2F</url>
    <content type="text"><![CDATA[操作步骤 先确定是否建立了主仓库的远程数据源: 1git remote -v 我们发现只有我们自己的两个源(fetch 和 push)，那这个时候就需要添加主仓库的源。 添加主仓库的源 1git remote add upstream URL upstream : 随便起的名字 URL： fork的仓库地址 如果想删除remote的upstream标签，则可以运行： git remote rm upstream 更新代码 123git fetch upstreamgit checkout mastergit merge upstream/master 参考https://blog.csdn.net/lhh1113/article/details/71038154]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSTACK 分析线程]]></title>
    <url>%2F2019%2F02%2F11%2FJava%2Fjstack-cpu%2F</url>
    <content type="text"><![CDATA[查找 tomcat 线程可以通过两种方式找： jps 一般Bootstrap都是tomcat的 ps -ef |grep tomcat jstack dump 出线程1jstack 23524 &gt; jstack.txt 查看 tomcat 内部线程1top -H -p 23524 （shift+p 按 cpu 排序，shift+m 按内存排序） 将PID换算成16进制，然后在jstack.txt查找nid=0x换算后的数1cat jstack.txt | grep 'nid=0x5be9' -B 5 -A 40 发现频繁的GC，推测是不是数据库在频繁的开关导致，因此检查 tomcat jndi是否没配置数据库连接池参数 加上连接池参数 参考jstack分析cpu负载过高原因： https://blog.csdn.net/u010248330/article/details/80080605 jstack: Java占用高CPU分析之- GC Task Thread: https://blog.csdn.net/chenxiusheng/article/details/74007040]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 传入参数为 List、Array、Map]]></title>
    <url>%2F2019%2F02%2F08%2FJava%2FMyBatis%2Fmybatis-collection-params%2F</url>
    <content type="text"><![CDATA[foreach 标签简单介绍主要用于在SQL语句中构建循环体 标签的主要属性有 item，index，collection，open，separator，close。 属性 描述 item 集合中每一个元素进行迭代时的别名。该参数为必选。 index 指定一个名字，用于表示在迭代过程中，没错迭代到的位置 open 表示该语句以什么开始 close 表示该语句以什么结束 separator 表示在每次进行迭代之间以什么符号作为分隔符 collection 属性是在使用foreach的时候最关键的也是最容易出错的，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况： (1) 如果传入的是单参数且参数类型是一个List的时候，collection属性值为list .(2) 如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array .(3) 如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key.(4) 如果参数使用了@Param注解，那必须是参数名 示例建表语句1234567891011121314151617181920212223242526272829DROP TABLE IF EXISTS `XXGL_CODE_COMBINATIONS`;CREATE TABLE `XXGL_CODE_COMBINATIONS`( `COMBINATION_ID` bigint AUTO_INCREMENT NOT NULL COMMENT '表ID，主键，供其他表做外键' , `CODE_COMBINATION_ID` bigint NOT NULL , `ENABLED_FLAG` varchar(1) NOT NULL COMMENT 'Y/N' , `ACCOUNT_TYPE` varchar(10) NOT NULL COMMENT '账户类型' , `SEGMENT1` varchar(25) NULL COMMENT '段值1', `SEGMENT2` varchar(25) NULL COMMENT '段值2', `SEGMENT3` varchar(25) NULL COMMENT '段值3', `SEGMENT4` varchar(25) NULL COMMENT '段值4', `SEGMENT5` varchar(25) NULL COMMENT '段值5', `SEGMENT6` varchar(25) NULL COMMENT '段值6', `SEGMENT7` varchar(25) NULL COMMENT '段值7', `SEGMENT8` varchar(25) NULL COMMENT '段值8', `SEGMENT9` varchar(25) NULL COMMENT '段值9', `SEGMENT10` varchar(25) NULL COMMENT '段值10', `SEGMENT11` varchar(25) NULL COMMENT '段值11', `SEGMENT12` varchar(25) NULL COMMENT '段值12', `SEGMENT13` varchar(25) NULL COMMENT '段值13', `SEGMENT14` varchar(25) NULL COMMENT '段值14', `SEGMENT15` varchar(25) NULL COMMENT '段值15', `SEGMENT16` varchar(25) NULL COMMENT '段值16', `SEGMENT17` varchar(25) NULL COMMENT '段值17', `SEGMENT18` varchar(25) NULL COMMENT '段值18', PRIMARY KEY (`COMBINATION_ID`), UNIQUE KEY `XXGL_CODE_COMBINATIONS_U1` (`COMBINATION_ID`), KEY `XXGL_CODE_COMBINATIONS_N1` (`CODE_COMBINATION_ID`)) ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8; 测试数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647INSERT INTO `XXGL_CODE_COMBINATIONS` ( `CODE_COMBINATION_ID`, `ENABLED_FLAG`, `ACCOUNT_TYPE`, `SEGMENT1`, `SEGMENT2`, `SEGMENT3`, `SEGMENT4`, `SEGMENT5`, `SEGMENT6`, `SEGMENT7`, `SEGMENT8`, `SEGMENT9`, `SEGMENT10`, `SEGMENT11`, `SEGMENT12`, `SEGMENT13`, `SEGMENT14`, `SEGMENT15`, `SEGMENT16`, `SEGMENT17`, `SEGMENT18`)VALUES ( 300000003238305, 'Y', 'E', '050', '0', '71205', 'S101005', '50010', '1101', 'I101', '0', '0', '0', '0', '0', NULL, NULL, NULL, NULL, NULL, NULL ); 实体类（CodeCombinations.java）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import javax.persistence.GeneratedValue;import javax.persistence.Id;import org.hibernate.validator.constraints.Length;import javax.persistence.Table;import javax.validation.constraints.NotNull;/** * Created by xiaofeng.he on 2018/03/08 * 帐号组合DTO */@Table(name = "XXGL_CODE_COMBINATIONS")public class CodeCombinations &#123; @Id @GeneratedValue private Long combinationId; // 表ID，主键，供其他表做外键 @NotNull private Long codeCombinationId; // ERP中CODE_COMBINATION_ID private String accountType; private String enabledFlag; @Length(max = 25) private String segment1; @Length(max = 25) private String segment2; @Length(max = 25) private String segment3; @Length(max = 25) private String segment4; @Length(max = 25) private String segment5; @Length(max = 25) private String segment6; @Length(max = 25) private String segment7; @Length(max = 25) private String segment8; @Length(max = 25) private String segment9; @Length(max = 25) private String segment10; @Length(max = 25) private String segment11; @Length(max = 25) private String segment12; @Length(max = 25) private String segment13; @Length(max = 25) private String segment14; @Length(max = 25) private String segment15; @Length(max = 25) private String segment16; @Length(max = 25) private String segment17; @Length(max = 25) private String segment18; // getter setter...&#125; java mapper123456789101112131415161718192021222324252627282930import org.apache.ibatis.annotations.Param;/** * Created by xiaofeng.he on 2018/03/08 * 账户组合mapper */public interface CodeCombinationsMapper &#123; /** * 根据多个 segment value 查询唯一 * @param segmentValues * @return */ CodeCombinations selectOneBySegmentArray(@Param("segmentValues") String[] segmentValues); /** * 根据多个 segment value 查询唯一 * @param segmentValues * @return */ CodeCombinations selectOneBySegmentList(List&lt;String&gt; segmentValues); /** * 根据多个 segment value 查询唯一 * @param params * @return */ CodeCombinations selectOneBySegmentMap(Map&lt;String, Object&gt; params);&#125; xml mapper1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="xxx.mapper.CodeCombinationsMapper"&gt; &lt;resultMap id="BaseResultMap" type="xxx.dto.CodeCombinations"&gt; &lt;result column="COMBINATION_ID" property="combinationId" jdbcType="DECIMAL" /&gt; &lt;result column="CODE_COMBINATION_ID" property="codeCombinationId" jdbcType="DECIMAL" /&gt; &lt;result column="ACCOUNT_TYPE" property="accountType" jdbcType="VARCHAR" /&gt; &lt;result column="ENABLED_FLAG" property="enabledFlag" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT1" property="segment1" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT2" property="segment2" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT3" property="segment3" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT4" property="segment4" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT5" property="segment5" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT6" property="segment6" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT7" property="segment7" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT8" property="segment8" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT9" property="segment9" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT10" property="segment10" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT11" property="segment11" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT12" property="segment12" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT13" property="segment13" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT14" property="segment14" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT15" property="segment15" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT16" property="segment16" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT17" property="segment17" jdbcType="VARCHAR" /&gt; &lt;result column="SEGMENT18" property="segment18" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;!--Array:forech 中的 collection 属性类型是 Array, collection 的值必须是:array, item 的值可以随意, mapper 接口中参数名字随意 --&gt; &lt;select id="selectOneBySegmentArray" resultMap="BaseResultMap"&gt; select c.* from XXGL_CODE_COMBINATIONS c &lt;where&gt; and c.ENABLED_FLAG = 'Y' &lt;choose&gt; &lt;when test="segmentValues"&gt; &lt;!-- 使用了@Param 后collection不能填array，要填写别名 --&gt; &lt;foreach collection="segmentValues" item="segmentValue" index="index"&gt; and c.SEGMENT$&#123;index+1&#125; = #&#123;segmentValue&#125; &lt;/foreach&gt; &lt;/when&gt; &lt;otherwise&gt; and 1=2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; &lt;!--List:forech 中的 collection 属性类型是 List, collection 的值必须是:list, item 的值可以随意, mapper 接口中参数名字随意 --&gt; &lt;select id="selectOneBySegmentList" resultMap="BaseResultMap"&gt; select c.* from XXGL_CODE_COMBINATIONS c &lt;where&gt; and c.ENABLED_FLAG = 'Y' &lt;choose&gt; &lt;when test="list"&gt; &lt;foreach collection="list" item="segmentValue" index="index"&gt; and c.SEGMENT$&#123;index+1&#125; = #&#123;segmentValue&#125; &lt;/foreach&gt; &lt;/when&gt; &lt;otherwise&gt; and 1=2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; &lt;!--Map:不单单 forech 中的 collection 属性是 map.key,其它所有属性都是 map.key, 比如下面的 enabledFlag --&gt; &lt;select id="selectOneBySegmentMap" resultMap="BaseResultMap"&gt; select c.* from XXGL_CODE_COMBINATIONS c &lt;where&gt; and c.ENABLED_FLAG = #&#123;enabledFlag&#125; &lt;choose&gt; &lt;when test="segmentArray"&gt; &lt;foreach collection="segmentArray" item="segmentValue" index="index"&gt; and c.SEGMENT$&#123;index+1&#125; = #&#123;segmentValue&#125; &lt;/foreach&gt; &lt;/when&gt; &lt;otherwise&gt; and 1=2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;choose&gt; &lt;when test="segmentList"&gt; &lt;foreach collection="segmentList" item="segmentValue" index="index"&gt; /* 2 */ and c.SEGMENT$&#123;index+1&#125; = #&#123;segmentValue&#125; &lt;/foreach&gt; &lt;/when&gt; &lt;otherwise&gt; and 1=2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 测试 controller123456789101112131415161718192021222324252627282930313233import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;import xxx.dto.CodeCombinations;import xxx.mapper.CodeCombinationsMapper;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;@Controllerpublic class TestController &#123; @Autowired private CodeCombinationsMapper codeCombinationsMapper; @GetMapping("/test/code/combination/selectBySegments") @ResponseBody public List&lt;CodeCombinations&gt; test() &#123; String[] a = &#123;"050", "0", "71205", "S101005", "50010", "1101", "I101"&#125;; CodeCombinations codeCombinations1 = codeCombinationsMapper.selectOneBySegments(a); CodeCombinations codeCombinations2 = codeCombinationsMapper.selectOneBySegmentList(Arrays.asList(a)); Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put("enabledFlag", "Y"); params.put("segmentArray", a); params.put("segmentList", Arrays.asList(a)); CodeCombinations codeCombinations3 = codeCombinationsMapper.selectOneBySegmentMap(params); return Arrays.asList(codeCombinations1, codeCombinations2, codeCombinations3); &#125;&#125; 测试结果log 12345678910112019-02-08 22:40:40.523 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegments - ==&gt; Preparing: select c.* from XXGL_CODE_COMBINATIONS c WHERE c.ENABLED_FLAG = 'Y' and c.SEGMENT1 = ? and c.SEGMENT2 = ? and c.SEGMENT3 = ? and c.SEGMENT4 = ? and c.SEGMENT5 = ? and c.SEGMENT6 = ? and c.SEGMENT7 = ? 2019-02-08 22:40:40.524 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegments - ==&gt; Parameters: 050(String), 0(String), 71205(String), S101005(String), 50010(String), 1101(String), I101(String)2019-02-08 22:40:40.532 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegments - &lt;== Total: 12019-02-08 22:40:43.259 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentList - ==&gt; Preparing: select c.* from XXGL_CODE_COMBINATIONS c WHERE c.ENABLED_FLAG = 'Y' and c.SEGMENT1 = ? and c.SEGMENT2 = ? and c.SEGMENT3 = ? and c.SEGMENT4 = ? and c.SEGMENT5 = ? and c.SEGMENT6 = ? and c.SEGMENT7 = ? 2019-02-08 22:40:43.259 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentList - ==&gt; Parameters: 050(String), 0(String), 71205(String), S101005(String), 50010(String), 1101(String), I101(String)2019-02-08 22:40:43.263 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentList - &lt;== Total: 12019-02-08 22:40:44.284 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentMap - ==&gt; Preparing: select c.* from XXGL_CODE_COMBINATIONS c WHERE c.ENABLED_FLAG = ? and c.SEGMENT1 = ? and c.SEGMENT2 = ? and c.SEGMENT3 = ? and c.SEGMENT4 = ? and c.SEGMENT5 = ? and c.SEGMENT6 = ? and c.SEGMENT7 = ? /* 2 */ and c.SEGMENT1 = ? /* 2 */ and c.SEGMENT2 = ? /* 2 */ and c.SEGMENT3 = ? /* 2 */ and c.SEGMENT4 = ? /* 2 */ and c.SEGMENT5 = ? /* 2 */ and c.SEGMENT6 = ? /* 2 */ and c.SEGMENT7 = ? 2019-02-08 22:40:44.284 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentMap - ==&gt; Parameters: Y(String), 050(String), 0(String), 71205(String), S101005(String), 50010(String), 1101(String), I101(String), 050(String), 0(String), 71205(String), S101005(String), 50010(String), 1101(String), I101(String)2019-02-08 22:40:44.289 DEBUG [10001] [e5c47fa7c79b461a806c2d6135d485c2] xxx.mapper.CodeCombinationsMapper.selectOneBySegmentMap - &lt;== Total: 1 json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374[&#123;"combinationId": 1000,"codeCombinationId": 300000003238305,"accountType": "E","enabledFlag": "Y","segment1": "050","segment2": "0","segment3": "71205","segment4": "S101005","segment5": "50010","segment6": "1101","segment7": "I101","segment8": "0","segment9": "0","segment10": "0","segment11": "0","segment12": "0","segment13": null,"segment14": null,"segment15": null,"segment16": null,"segment17": null,"segment18": null&#125;,&#123;"combinationId": 1000,"codeCombinationId": 300000003238305,"accountType": "E","enabledFlag": "Y","segment1": "050","segment2": "0","segment3": "71205","segment4": "S101005","segment5": "50010","segment6": "1101","segment7": "I101","segment8": "0","segment9": "0","segment10": "0","segment11": "0","segment12": "0","segment13": null,"segment14": null,"segment15": null,"segment16": null,"segment17": null,"segment18": null&#125;,&#123;"combinationId": 1000,"codeCombinationId": 300000003238305,"accountType": "E","enabledFlag": "Y","segment1": "050","segment2": "0","segment3": "71205","segment4": "S101005","segment5": "50010","segment6": "1101","segment7": "I101","segment8": "0","segment9": "0","segment10": "0","segment11": "0","segment12": "0","segment13": null,"segment14": null,"segment15": null,"segment16": null,"segment17": null,"segment18": null&#125;] 感谢https://blog.csdn.net/s592652578/article/details/52871884]]></content>
      <categories>
        <category>Java</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[航天信息金税盘接口 js 调用]]></title>
    <url>%2F2018%2F12%2F02%2Fessay%2Fgold-tax-js%2F</url>
    <content type="text"><![CDATA[背景 最近项目要求与单机版的金税盘接口进行对接，在这里简单记录一下自己的开发经验，希望可以帮助到有需要的人 PS：接口使用 js 对接，仅支持 ie 浏览器。 前置条件在进行开发时候需要有一些前置条件 ie 浏览器 开启 activeX 控件 设置 –&gt; Internet 选项 –&gt; 安全 –&gt; 自定义级别 把 activeX 相关设置勾上 可参考: 管理员身份运行调试 如果开票软件安装到本地 C盘 需要使用管理员打开 ie 浏览器，然后再进行调试 金税盘安装 要确保金税盘安装准确安装了TaxCardX.dll 通用 js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395/** 航信金税盘相关function */var goldTax = &#123; /** * 使用前先判断是否是ie浏览器 * @return true/false */ isIE: function () &#123; if(!!window.ActiveXObject || "ActiveXObject" in window) return true; else return false; &#125;, /** * 开启金税盘 * @param certPassword 单机版为证书口令 服务器版为地址 留空则读取开票BIN文件下cert.txt * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx', // 错误信息 * 'data': &#123;&#125; // 接口返回相关数据 * &#125; * &lt;/pre&gt; */ openCard: function (certPassword) &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '', 'data': &#123;&#125; &#125;; try &#123; goldTax.card = new ActiveXObject("TaxCardX.GoldTax"); // 单机版为证书口令 服务器版为地址 留空则读取开票BIN文件下cert.txt if(typeof certPassword != 'undefined') &#123; goldTax.card.CertPassword = certPassword; &#125; // 开启金税盘 goldTax.card.OpenCard(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // 1011 开启成功 if (result.code == 1011) &#123; result.success = true; result.data = &#123; RetCode: goldTax.card.RetCode, /* RetCode - 状态码， 1011 开启成功 */ RetMsg: goldTax.card.RetMsg, /* RetMsg 状态信息 */ InvLimit: goldTax.card.InvLimit, /* InvLimit – 开票限额, 金税卡发票开具价税合计限额 */ TaxCode: goldTax.card.TaxCode, /* TaxCode 本单位税号 */ TaxClock: goldTax.card.TaxClock, /* TaxClock – 金税卡时钟 */ MachineNo: goldTax.card.MachineNo, /* MachineNo – 开票机号码，主开票机为 0 */ IsInvEmpty: goldTax.card.IsInvEmpty, /* IsInvEmpty – 有票标志，0为金税卡中无可开发票，1为有票 */ IsRepReached: goldTax.card.IsRepReached, /* IsRepReached – 抄税标志，0为未到抄税期，1为已到抄税期 */ IsLockReached: goldTax.card.IsLockReached, /* IsLockReached – 锁死标志，0为未到锁死期，1为已到锁死期 */ &#125;; &#125; else &#123; result.success = false; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125;, /** * 关闭金税盘 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx' // 错误信息 * &#125; * &lt;/pre&gt; */ closeCard: function() &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '' &#125;; if (typeof goldTax.card != 'undefined') &#123; try &#123; goldTax.card.closeCard(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // RetCode 9000 调用成功，其他失败 if (result.code == 9000) &#123; result.success = true; &#125; else &#123; result.success = false; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125; &#125;, /** * 查询库存发票 * @param invKind 发票种类 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx', // 错误信息 * 'data': &#123;&#125; // 接口返回相关数据 * &#125; * &lt;/pre&gt; */ invoiceInventory: function(invKind) &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '', 'data': &#123;&#125; &#125;; try &#123; if (typeof goldTax.card != 'undefined') &#123; goldTax.card.InfoKind = invKind; goldTax.card.GetInfo(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // RetCode 3011 读取成功，其他失败 if (result.code == 3011) &#123; result.success = true; result.data = &#123; RetCode: goldTax.card.RetCode, /* RetCode - 状态码， 3011 读取成功，其他失败 */ RetMsg: goldTax.card.RetMsg, /* RetMsg 状态信息 */ InfoTypeCode: goldTax.card.InfoTypeCode, /* 要开具发票的十位代码。为空或全为0时，表示无可用发票 */ InfoNumber: goldTax.card.InfoNumber, /* 要开具发票的号码 */ InvStock: goldTax.card.InvStock, /* 剩余的可用发票份数 */ TaxClock: goldTax.card.TaxClock /* 金税盘时钟 */ &#125;; &#125; else &#123; result.success = false; &#125; &#125; else &#123; result.success = false; result.code = -1; result.msg = 'Please Open Card First'; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125;, /** * 发票校验 * @param o 传入发票信息 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx', // 错误信息 * 'data': &#123;&#125; // 接口返回相关数据 * &#125; * &lt;/pre&gt; */ invoiceVeriferify: function(o) &#123; return goldTax.inner.invoice(1, o); &#125;, /** * 发票开具 * @param o 传入发票信息 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx', // 错误信息 * 'data': &#123;&#125; // 接口返回相关数据 * &#125; * &lt;/pre&gt; */ invoicing: function(o) &#123; return goldTax.inner.invoice(0, o); &#125;, /** * 发票打印 * @param o 传入发票信息 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx' // 错误信息 * &#125; * &lt;/pre&gt; */ printInv: function(o) &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '' &#125;; try &#123; if (typeof goldTax.card != 'undefined') &#123; goldTax.card.InfoKind = o.InfoKind; /* 发票种类（0：专用发票 2：普通发票 11：货物运输业增值税专用发票 12：机动车销售统一发票） */ goldTax.card.InfoTypeCode = o.InfoTypeCode; /* 要打印发票的十位代码 */ goldTax.card.InfoNumber = o.InfoNumber; /* 要打印发票的号码 */ goldTax.card.GoodsListFlag = o.GoodsListFlag; /* 销货清单标志，0 – 打印发票，1 – 打印销货清单 */ goldTax.card.InfoShowPrtDlg = o.InfoShowPrtDlg; /* 打印时是否显示边距确认对话框，0 – 不出现，1 – 出现 */ // 调用接口 goldTax.card.PrintInv(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // RetCode 5011 打印成功，5001 – 未找到发票或清单，5012 – 未打印，5013 – 打印失败 if (result.code == 5011) &#123; result.success = true; &#125; else &#123; result.success = false; &#125; &#125; else &#123; result.success = false; result.code = -1; result.msg = 'Please Open Card First'; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125;, /** * 已开发票作废 * @param o 传入发票信息 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx' // 错误信息 * &#125; * &lt;/pre&gt; */ cancelInv: function(o) &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '' &#125;; try &#123; if (typeof goldTax.card != 'undefined') &#123; goldTax.card.InfoKind = o.InfoKind; /* 发票种类（0：专用发票 2：普通发票 11：货物运输业增值税专用发票 12：机动车销售统一发票） */ goldTax.card.InfoTypeCode = o.InfoTypeCode; /* 要作废发票的十位或十二位代码 */ goldTax.card.InfoNumber = o.InfoNumber; /* 要作废发票的号码 */ // 调用接口 goldTax.card.CancelInv(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // RetCode 6011 打印成功，6001 – 当月发票库未找到该发票，6002 – 该发票已经作废，6012 – 作废失败，6013 – 作废失败(异常) if (result.code == 6011) &#123; result.success = true; &#125; else &#123; result.success = false; &#125; &#125; else &#123; result.success = false; result.code = -1; result.msg = 'Please Open Card First'; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125;, // 内部方法 inner: &#123; /** * invoice 接口 * @param checkEWM 默认为0（0: 发票开具, 1: 发票校验, 2: 空白作废) * @param o 传入发票信息 * @return * &lt;pre&gt; * &#123; * 'success': true/false, // 成功或者失败 * 'code': -1/其他, // 错误码，-1 为系统错误 * 'msg': 'xxx', // 错误信息 * 'data': &#123;&#125; // 接口返回相关数据 * &#125; * &lt;/pre&gt; */ invoice: function(checkEWM, o) &#123; var result = &#123; 'success': false, 'code': -1, 'msg': '', 'data': &#123;&#125; &#125;; try &#123; if (typeof goldTax.card != 'undefined') &#123; // CheckEWM值默认为0（为1时用于发票校验。 // 注意：一旦CheckEWM值置1用于发票校验之后， //如果要再进行发票开具必须手动将CheckEWM值置为0，否则Invoice()方法的功能将一直处于发票校验状态） goldTax.card.CheckEWM = checkEWM; goldTax.card.InvInfoInit(); /* 初始化发票抬头信息 */ goldTax.card.InfoKind = o.InfoKind; /* 增值税普通发票2 专票0 */ goldTax.card.InfoClientName = o.InfoClientName; /* 购方名称 */ goldTax.card.InfoClientTaxCode = o.InfoClientTaxCode; /* 购方税号 */ goldTax.card.InfoClientBankAccount = o.InfoClientBankAccount; /* 购方开户行及账号 */ goldTax.card.InfoClientAddressPhone = o.InfoClientAddressPhone; /* 购方地址电话 */ goldTax.card.InfoSellerBankAccount = o.InfoSellerBankAccount; /* 销方开户行及账号 */ goldTax.card.InfoSellerAddressPhone = o.InfoSellerAddressPhone; /* 销方地址电话 */ // 如果是多商品多税率 税率应该放到下面商品信息循环里 if (typeof o.InfoTaxRate != 'undefined' &amp;&amp; o.InfoTaxRate) &#123; goldTax.card.InfoTaxRate = o.InfoTaxRate; /* 税率,(已授权的税率， 17% 传17) */ &#125; goldTax.card.InfoNotes = o.InfoNotes; /* 备注 */ goldTax.card.InfoInvoicer = o.InfoInvoicer; /* 开票人 */ // 复核人，可为空 if (typeof o.InfoChecker != 'undefined' &amp;&amp; o.InfoChecker) &#123; goldTax.card.InfoChecker = o.InfoChecker; &#125; // 收款人，可为空 if (typeof o.InfoCashier != 'undefined' &amp;&amp; o.InfoCashier) &#123; goldTax.card.InfoCashier = o.InfoCashier; &#125; // 如不为空，则开具销货清单，此为发票上商品名称栏的清单信息，应为“(详见销货清单)”字样 if (typeof o.InfoListName != 'undefined' &amp;&amp; o.InfoListName) &#123; goldTax.card.InfoListName = o.InfoListName; &#125; // 清空商品明细列表 goldTax.card.ClearInvList(); // 遍历行 $.each(o.InvList, function(i, v) &#123; goldTax.card.InvListInit(); /* 初始化发票明细信息各项属性 */ goldTax.card.ListGoodsName = v.ListGoodsName; /* 商品或劳务名称 */ goldTax.card.ListTaxItem = v.ListTaxItem; /* 税目，4位数字，商品所属类别 */ goldTax.card.ListStandard = v.ListStandard; /* 规格型号 */ // 计量单位，如计量单位为空，则忽略数量和单价 if (typeof v.ListUnit != 'undefined' &amp;&amp; v.ListUnit) &#123; goldTax.card.ListUnit = v.ListUnit; &#125; // 建议传入数量和含税单价或含税金额 由接口计算带小数的税额 规避误差 goldTax.card.ListNumber = v.ListNumber; // 数量 goldTax.card.ListPrice = v.ListPrice; // 单价 // 金额，可以不传(为0)，由接口软件计算，如传入则应符合计算关系 if (typeof v.ListAmount != 'undefined' &amp;&amp; v.ListAmount ) &#123; goldTax.card.ListAmount = v.ListAmount; &#125; goldTax.card.ListPriceKind = v.ListPriceKind; /* 含税价标志，单价和金额的种类， 0为不含税价，1为含税价 */ // 税额可以不传(为0)，由接口软件计算，如传入则应符合计算关系 if (typeof v.ListTaxAmount != 'undefined' &amp;&amp; v.ListTaxAmount) &#123; goldTax.card.ListTaxAmount = v.ListTaxAmount; &#125; // 添加一行 goldTax.card.AddInvList(); &#125;); // 调用接口 goldTax.card.Invoice(); result.code = goldTax.card.RetCode; result.msg = goldTax.card.RetMsg; // RetCode 4011 开票成功，其他失败 if (result.code == 4011) &#123; result.success = true; result.data = &#123; RetCode: goldTax.card.RetCode, /* RetCode - 状态码， 3011 读取成功，其他失败 */ RetMsg: goldTax.card.RetMsg, /* RetMsg 状态信息 */ InfoAmount: goldTax.card.InfoAmount , /* 合计不含税金额 */ InfoTaxAmount: goldTax.card.InfoTaxAmount, /* 合计税额 */ InfoInvDate: goldTax.card.InfoInvDate, /* 开票日期 */ InfMonth: goldTax.card.InfMonth, /* 所属月份 */ InfoTypeCode: goldTax.card.InfoTypeCode, /* 发票十位代码 */ InfoNumber: goldTax.card.InfoNumber, /* 发票号码 */ GoodsListFlag: goldTax.card.GoodsListFlag /* 销货清单标志，0 – 无销货清单，1 – 有销货清单 */ &#125;; &#125; else &#123; result.success = false; &#125; &#125; else &#123; result.success = false; result.code = -1; result.msg = 'Please Open Card First'; &#125; &#125; catch (e) &#123; result.success = false; result.code = -1; result.msg = 'ActiveX Error, ' + e.description; &#125; return result; &#125; &#125;&#125;; 相关资料CSDN 需要积分下载 金税 防伪税控 组件接口 开发文档 代码案例 没有积分的 戳这里]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ActiveX</tag>
        <tag>金税</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
